# DNF 引擎对 Squirrel 脚本调用机制详解

## 一、引言

### 1.1 背景与目的

本文基于台服 dnf 吧用户 “YoRHa” 的技术分享整理，旨在梳理 DNF 引擎对 Squirrel 脚本（后缀为`.nut`）的调用原理，为 DNF 技能魔改、脚本开发及 AI 学习提供系统化参考。分享者为计算机专业背景（掌握 C++/Java/Python），研究定位是 “整理自身理解 + 寻求大佬指正”，具有较强实践价值。

### 1.2 来源与受众



*   来源平台：百度贴吧 - 台服 dnf 吧（关注人数 121,888，贴子数 2,001,969）

*   发帖时间：2025 年 6 月 4 日

*   核心受众：DNF 脚本开发、技能魔改爱好者，以及 AI 学习相关场景。

## 二、核心概念：Squirrel 与 DNF 的关联

Squirrel 是 DNF 引擎使用的脚本语言，其脚本文件后缀为`.nut`（“Squirrel” 意为 “松鼠”，“nut” 意为 “坚果”，设计上有 “松鼠 - 坚果” 的趣味关联）。DNF 通过这套脚本系统实现技能逻辑、角色行为等定制化功能。

## 三、脚本加载机制

### 3.1 入口文件：`loadstate.nut`

`loadstate.nut`是 DNF 脚本加载的**核心入口**，路径为`sqr/loadstate.nut`。它在引擎启动游戏时自动预加载，功能类似编程语言中的 “头文件 / 引用包”，负责通过内部函数加载后续脚本文件及代码，是引擎识别脚本的 “第一站”。

### 3.2 关键加载函数：`sq_RunScript()` vs `dofile()`

两者均为脚本运行函数，但适用场景差异显著，具体对比如下：



| 对比维度    | `sq_RunScript()`        | `dofile()`           |
| ------- | ----------------------- | -------------------- |
| 核心用途    | 加载游戏封包内的`.nut`脚本        | 加载文件系统中的`.nut`脚本     |
| 路径规则    | 基于游戏资源目录的**相对路径**       | 绝对路径或基于项目目录的**相对路径** |
| 读取速度    | 直接从内存封包读取，速度快（多文件时优势明显） | 依赖磁盘 I/O，速度较慢        |
| 修改后生效方式 | 需重新打包 PVF 文件才能生效        | 实时生效（无需额外操作）         |
| 适用场景    | 成品脚本（追求性能，避免磁盘开销）       | 开发 / 测试阶段（方便实时调试修改）  |
| 补充说明    | 多文件场景下，速度差异可达 10 倍以上    | 仅建议开发环境使用，避免正式环境性能损耗 |

## 四、脚本加载策略：`pushScriptFiles`与`pushState`

在`loadstate.nut`调用的子脚本（如`Character/gunner_load_state.nut`）中，核心加载逻辑由`pushScriptFiles`和`pushState`实现，两者在 “加载策略” 和 “触发方式” 上存在本质区别。



| 对比维度      | `pushScriptFiles`         | `pushState`（全称：`IRDSQRCharacter.pushState`） |
| --------- | ------------------------- | ------------------------------------------- |
| 加载策略      | 预加载（全局加载），类似 “全局变量”       | 动态加载（状态触发加载）                                |
| 内存 / 性能开销 | 始终占用内存，开销较大               | 仅状态激活时占用内存，开销低、效率高                          |
| 触发方式      | 全局调用状态下，需开发者**手动检测状态 ID** | 检测到指定状态后，引擎**自动调用**对应脚本                     |
| 响应速度      | 因需手动检测，响应速度略慢             | 状态触发即调用，响应速度更快                              |
| 适用场景      | 逻辑通用、需全局复用的脚本（如基础角色逻辑）    | 特定状态触发的脚本（如技能释放、角色受伤）                       |

## 五、DNF 引擎双轨触发机制（核心）

DNF 引擎对脚本的 “自动调用” 依赖**双轨触发机制**，无需开发者手动编写 “主调函数”，即可实现函数的自动识别与执行。

### 5.1 第一轨：函数签名驱动机制（主要方式）

#### 5.1.1 核心原理

引擎通过**预定义的函数名模式（签名）** 扫描全局已加载脚本，只要函数存在且签名匹配，无需注册即可在对应事件发生时自动调用，与 “函数所在文件位置” 无关。

#### 5.1.2 关键规则与示例



*   识别规则：函数名需符合 “事件前缀 + 角色 / 场景标识” 的固定格式。

*   触发条件：对应游戏事件发生（如技能释放、角色受伤）。

*   典型应用场景（通用事件处理，最高效）：



```
// 所有技能释放后触发（ATGunner为“女枪手”职业标识）

function useSkill\_after\_ATGunner(...)&#x20;

// 角色受伤时触发

function onDamage\_ATGunner(...)      &#x20;

// 全局状态开始时回调（无职业限制）

function onStateStart(...)
```

### 5.2 第二轨：状态注册驱动机制（辅助方式）

#### 5.2.1 核心原理

需先通过`pushState`函数建立 “状态 ID 与脚本” 的映射关系，仅当指定状态激活时，引擎才会调用脚本中带固定后缀的函数，属于 “依赖注册的定向触发”。

#### 5.2.2 关键步骤与示例



1.  **注册状态（建立映射）**：

    通过`pushState`函数绑定 “职业、脚本路径、函数前缀、状态类型、优先级”，示例代码：



```
IRDSQRCharacter.pushState(

&#x20;   ENUM\_CHARACTERJOB\_SWORDMAN,         // 指定职业：剑魂（剑系职业）

&#x20;   "Character/swordman/swordman\_aaa.nut", // 脚本文件路径

&#x20;   "swordman\_aaa",                   // 函数前缀（后续函数需包含此前缀）

&#x20;   13,                               // 处理的状态类型（如“技能释放中”）

&#x20;   -1                                // 优先级（-1为默认）

);
```



1.  **自动调用规则**：

    当角色进入 “状态类型 13” 时，引擎会自动调用脚本中带 “固定后缀” 的函数，后缀与 “状态生命周期” 对应：



| 函数格式                     | 触发时机        | 示例                               |
| ------------------------ | ----------- | -------------------------------- |
| `"onStart"+函数前缀`         | 状态开始时       | `onStart_swordman_aaa()`         |
| `"proc"+函数前缀`            | 状态持续中（每帧更新） | `proc_swordman_aaa()`            |
| `"onEnd"+函数前缀`           | 状态结束时       | `onEnd_swordman_aaa()`           |
| `"onAfterSetState"+函数前缀` | 状态设置完成后     | `onAfterSetState_swordman_aaa()` |

#### 5.2.3 注意事项



*   社区补充（用户 “爱媛儿”）：状态注册时的 “状态类型” 需与 “技能 index” 匹配，若不匹配可能导致 “黑技能”（技能无法正常显示 / 使用）。

## 六、开发实践建议



1.  **加载函数选择**：开发 / 测试阶段用`dofile()`（实时生效，方便调试），成品脚本改用`sq_RunScript()`（内存读取，提升性能）。

2.  **加载策略选择**：通用逻辑用`pushScriptFiles`（全局预加载），特定状态逻辑用`pushState`（动态加载，节省内存）。

3.  **函数命名规范**：使用 “函数签名驱动” 时，严格遵循 “事件前缀 + 职业名” 格式（如`useSkill_after_职业名`），避免引擎无法识别。

4.  **代码管理**：多开发者协作时统一代码风格（原帖提及 “封包内多开发者代码风格迥异，影响可读性”）。

## 七、总结与补充

### 7.1 研究局限性

分享者 “YoRHa” 明确表示 “非专业程序员，仅为技能魔改需求进行研究”，部分原理可能存在简化，需结合资深开发者经验进一步验证。

### 7.2 后续计划

分享者计划通过 “编写自定义技能脚本” 验证当前对调用机制的理解，可关注其后续更新。

### 7.3 社区价值

该研究旨在 “为后来者减少学习难度与时间成本”，是 DNF 脚本开发、技能魔改的入门参考，也为 AI 学习 DNF 脚本机制提供了结构化素材。

> （注：文档部分内容可能由 AI 生成）