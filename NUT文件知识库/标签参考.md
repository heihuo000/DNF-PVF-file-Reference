# NUT脚本标签参考

## 🎯 核心概念

### State（状态）
NUT脚本的核心概念，代表技能或角色的不同状态阶段。

**功能作用**：
- 定义技能的执行阶段和状态转换
- 控制角色行为和动画播放
- 管理技能的生命周期

**使用方式**：
```nut
// 状态定义示例
STATE_SKILL_NAME <- 101  // 自定义状态编号，避免冲突
```

**状态管理最佳实践**：
- 状态编号使用100以上，避免与系统状态冲突
- 每个技能至少需要一个主状态
- 复杂技能可以定义多个子状态进行精细控制

## 🔧 核心函数详解

### 1. checkExecutableSkill_* 系列
**功能作用**：检查技能是否可以执行的前置条件

**参数详解**：
- `obj`: 角色对象
- 返回值: `true`/`false` 表示是否可执行

**实际应用**：
```nut
function checkExecutableSkill_SkillName(obj)
{
    if(!obj) return false;
    
    // 检查MP是否足够
    local needMp = obj.sq_GetIntData(SKILL_SKILLNAME, SKL_MP_CONSUMPTION);
    if(obj.sq_GetMp() < needMp) return false;
    
    // 检查冷却时间
    if(obj.sq_IsUseSkill(SKILL_SKILLNAME)) return false;
    
    // 检查角色状态（不能在僵直、浮空等状态下使用）
    if(obj.sq_IsDownState() || obj.sq_IsHoldState()) return false;
    
    return true;
}
```

### 2. onSetState_* 系列
**功能作用**：技能状态设置时的核心处理函数

**参数详解**：
- `obj`: 角色对象
- `state`: 当前状态
- `datas`: 状态数据数组
- `isResetTimer`: 是否重置计时器

**实际应用**：
```nut
function onSetState_SkillName(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 根据不同状态执行不同逻辑
    if(state == STATE_SKILL_CAST)
    {
        // 设置动画
        obj.sq_SetCurrentAnimation(ANIMATION_SKILL_CAST);
        
        // 停止移动
        obj.sq_StopMove();
        
        // 设置无敌状态（可选）
        obj.sq_SetCurrentAttackInfo(ATTACKINFO_INVINCIBLE);
        
        // 消耗MP
        local needMp = obj.sq_GetIntData(SKILL_SKILLNAME, SKL_MP_CONSUMPTION);
        obj.sq_AddMp(-needMp);
        
        // 设置技能冷却
        obj.sq_UseSkill(SKILL_SKILLNAME, true);
    }
    else if(state == STATE_SKILL_ATTACK)
    {
        // 攻击阶段逻辑
        obj.sq_SetCurrentAnimation(ANIMATION_SKILL_ATTACK);
        
        // 创建攻击判定
        createAttackBox(obj);
    }
}
```

### 3. onEndCurrentAni_* 系列
**功能作用**：当前动画结束时的处理函数

**参数详解**：
- `obj`: 角色对象

**实际应用**：
```nut
function onEndCurrentAni_SkillName(obj)
{
    if(!obj) return;
    
    // 动画结束后的状态转换
    local state = obj.sq_GetState();
    
    if(state == STATE_SKILL_CAST)
    {
        // 施法动画结束，转入攻击状态
        obj.sq_AddSetStatePacket(STATE_SKILL_ATTACK, STATE_PRIORITY_USER, true);
    }
    else if(state == STATE_SKILL_ATTACK)
    {
        // 攻击动画结束，返回站立状态
        obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, true);
    }
}
```

### 4. onKeyFrameFlag_* 系列
**功能作用**：动画关键帧触发时的处理函数

**参数详解**：
- `obj`: 角色对象
- `flagIndex`: 关键帧索引

**实际应用**：
```nut
function onKeyFrameFlag_SkillName(obj, flagIndex)
{
    if(!obj) return;
    
    // 根据不同关键帧执行不同逻辑
    switch(flagIndex)
    {
        case 1:
            // 第一个关键帧：创建特效
            createSkillEffect(obj);
            break;
            
        case 2:
            // 第二个关键帧：创建攻击判定
            createAttackBox(obj);
            break;
            
        case 3:
            // 第三个关键帧：播放音效
            obj.sq_PlaySound(`SKILL_SOUND`);
            break;
    }
}
```

### 5. onAttack_* 系列
**功能作用**：角色攻击时的处理函数

**参数详解**：
- `obj`: 攻击者对象
- `damager`: 被攻击者对象
- `boundingBox`: 攻击范围
- `isStuck`: 是否卡住

**实际应用**：
```nut
function onAttack_SkillName(obj, damager, boundingBox, isStuck)
{
    if(!obj || !damager) return;
    
    // 获取技能等级
    local skillLevel = obj.sq_GetSkillLevel(SKILL_SKILLNAME);
    
    // 计算伤害
    local damage = calculateSkillDamage(obj, skillLevel);
    
    // 应用伤害
    damager.sq_AddDamage(damage);
    
    // 添加状态效果（如冰冻、燃烧等）
    if(skillLevel >= 5)
    {
        // 高等级技能附加特殊效果
        sq_AppendAppendage(damager, obj, APPENDAGE_FREEZE, true, `freeze.ap`, true);
    }
    
    // 击退效果
    local pushPower = obj.sq_GetIntData(SKILL_SKILLNAME, SKL_PUSH_POWER);
    damager.sq_AddForce(pushPower, 0);
}
```

## 🎮 回调函数系统

### 角色回调函数
基于DAF学院教程，以下是常用的角色回调函数：

#### 1. drawMainCustomUI_* 系列
**功能作用**：在城镇和副本内都持续循环执行的UI绘制函数

**使用场景**：
- 全局UI显示（如血条、状态显示）
- 持续性特效绘制
- 全局状态监控

```nut
function drawMainCustomUI_Swordman(obj)
{
    if(!obj) return;
    
    // 绘制自定义血条
    drawCustomHealthBar(obj);
    
    // 绘制技能冷却显示
    drawSkillCooldown(obj);
}
```

#### 2. drawCustomUI_* 系列
**功能作用**：仅在副本内持续循环执行的UI绘制函数

**使用场景**：
- 副本内专用UI
- 战斗状态显示
- 副本特殊效果

```nut
function drawCustomUI_Swordman(obj)
{
    if(!obj) return;
    
    // 仅在副本内显示的战斗信息
    drawBattleInfo(obj);
    
    // 显示连击数
    drawComboCounter(obj);
}
```

#### 3. onStartDungeon_* 系列
**功能作用**：副本开始时调用一次

```nut
function onStartDungeon_Swordman(obj)
{
    if(!obj) return;
    
    // 副本开始时的初始化
    initializeDungeonBuffs(obj);
    
    // 重置技能冷却
    resetAllSkillCooldown(obj);
}
```

#### 4. onStartMap_* 系列
**功能作用**：每个房间开始时调用一次

```nut
function onStartMap_Swordman(obj)
{
    if(!obj) return;
    
    // 房间开始时的处理
    applyRoomBuffs(obj);
    
    // 恢复部分MP
    local currentMp = obj.sq_GetMp();
    obj.sq_SetMp(currentMp + 100);
}
```

#### 5. procAppend_* 系列
**功能作用**：在副本内持续循环调用，用于AP加载

```nut
function procAppend_Swordman(obj)
{
    if(!obj) return;
    
    // 检查并应用持续性效果
    checkAndApplyPassiveEffects(obj);
    
    // 监控角色状态
    monitorCharacterStatus(obj);
}
```

## 📦 AP（Appendage）系统详解

### AP系统概念
AP可以理解为给对象装上的"监控器"，能够监视对象的一举一动并执行相应操作。

### AP创建语法
```nut
sq_AppendAppendage(obj1, obj2, id, false, `ap文件名`, true);
```

**参数说明**：
- `obj1`: 被监控的对象（监控装给谁）
- `obj2`: 监控的创建者（谁装的监控）
- `id`: 监控的唯一标识（监控的品牌）
- `ap文件名`: AP文件路径（监控从哪里买来的）

### AP函数执行顺序
根据DAF学院教程，AP函数有固定的执行顺序：

1. **onStart**: AP刚开始时执行一次
2. **onStartMap**: 进入每个副本房间时执行一次
3. **proc**: AP空闲时循环执行（阻塞方法）
4. **onSetHp**: 对象血量变化时执行一次
5. **prepareDraw**: 准备绘制时循环执行
6. **drawAppend**: 绘制AP时循环执行
7. **onChangeState**: 对象改变状态时执行一次
8. **onApplyHpDamage**: 对象受到伤害时执行一次
9. **onAttackParent**: 对象攻击时执行一次
10. **onDamageParent**: 对象受到伤害时执行一次
11. **getImmuneTypeDamageRate**: 获取属性攻击比率时执行一次
12. **onVaildTimeEnd**: 监控失效时执行一次
13. **onDestroyObject**: 对象受到攻击时执行一次
14. **isEnd**: 判断AP是否结束
15. **onEnd**: 返回城镇或对象死亡时执行一次

### AP模板示例
```nut
// AP文件基本结构
appendage.sq_AddFunctionName(`onStart`, ``);
appendage.sq_AddFunctionName(`onStartMap`, ``);
appendage.sq_AddFunctionName(`proc`, ``);
appendage.sq_AddFunctionName(`onSetHp`, ``);
appendage.sq_AddFunctionName(`prepareDraw`, ``);
appendage.sq_AddFunctionName(`drawAppend`, ``);
appendage.sq_AddFunctionName(`onChangeState`, ``);
appendage.sq_AddFunctionName(`onApplyHpDamage`, ``);
appendage.sq_AddFunctionName(`onAttackParent`, ``);
appendage.sq_AddFunctionName(`onDamageParent`, ``);
appendage.sq_AddFunctionName(`getImmuneTypeDamageRate`, ``);
appendage.sq_AddFunctionName(`onSourceKeyFrameFlag`, ``);
appendage.sq_AddFunctionName(`onVaildTimeEnd`, ``);
appendage.sq_AddFunctionName(`onDestroyObject`, ``);
appendage.sq_AddFunctionName(`isEnd`, ``);
appendage.sq_AddFunctionName(`onEnd`, ``);

function onStart_ap(appendage)
{
    if(!appendage) return;
    
    local obj = appendage.getParent();
    if(!obj) return;
    
    // AP开始时的初始化逻辑
    appendage.sq_SetValidTime(5000); // 设置AP持续时间5秒
}

function proc_ap(appendage)
{
    if(!appendage) return;
    
    local obj = appendage.getParent();
    if(!obj) return;
    
    // 持续执行的逻辑
    // 例如：持续回血、持续伤害等
}

function onEnd_ap(appendage)
{
    if(!appendage) return;
    
    local obj = appendage.getParent();
    if(!obj) return;
    
    // AP结束时的清理逻辑
    removeBuffEffects(obj);
}
```
- `datas`: 状态数据
- `isResetTimer`: 是否重置计时器

**实际应用**：
```nut
function onSetState_SkillName(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 设置动画
    obj.sq_SetCurrentAnimation(CUSTOM_ANI_SKILLNAME);
    
    // 设置移动状态
    obj.sq_StopMove();
    
    // 设置计时器
    obj.sq_SetStaticSpeedInfo(SPEED_TYPE_ATTACK_SPEED, 
        SPEED_TYPE_ATTACK_SPEED, SPEED_VALUE_DEFAULT, 
        SPEED_VALUE_DEFAULT, 1.0, 1.0);
}
```

### 3. onAttack_* 系列
**功能作用**：处理攻击判定和伤害计算

**参数详解**：
- `obj`: 攻击者对象
- `damager`: 伤害对象
- `boundingBox`: 攻击范围
- `isStuck`: 是否造成硬直

**实际应用**：
```nut
function onAttack_SkillName(obj, damager, boundingBox, isStuck)
{
    if(!obj || !damager) return;
    
    // 设置伤害倍率
    damager.sq_SetDamageRate(120); // 120%伤害
    
    // 设置攻击属性
    damager.sq_SetAttackInfo(SAI_IS_MAGIC, true);
    
    // 添加状态效果
    damager.sq_SetChangeStatusIntoAttackInfo(ACTIVESTATUS_STUCK, 
        0, 200, 1000, 0);
}
```

### 4. onTimeEvent_* 系列
**功能作用**：处理时间事件和状态转换

**参数详解**：
- `obj`: 角色对象
- `timeEventIndex`: 时间事件索引
- `timeEventCount`: 事件计数

**实际应用**：
```nut
function onTimeEvent_SkillName(obj, timeEventIndex, timeEventCount)
{
    if(!obj) return;
    
    switch(timeEventIndex)
    {
        case TIMER_ATTACK_START:
            // 开始攻击判定
            obj.sq_StartWrite();
            obj.sq_WriteDword(timeEventIndex);
            obj.sq_SendCreatePassiveObjectPacket(24210, 0, 0, 0, 0);
            break;
            
        case TIMER_SKILL_END:
            // 技能结束
            obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, true);
            break;
    }
}
```

## 📊 常用对象方法

### obj 对象核心方法

#### 状态控制
- `obj.sq_AddSetStatePacket(state, priority, isResetTimer)`: 设置状态
- `obj.sq_SetCurrentAnimation(aniIndex)`: 设置动画
- `obj.sq_StopMove()`: 停止移动
- `obj.sq_SetStaticSpeedInfo()`: 设置速度信息

#### 技能检查
- `obj.sq_IsUseSkill(skillIndex)`: 检查技能是否在使用
- `obj.sq_GetSkillLevel(skillIndex)`: 获取技能等级
- `obj.sq_GetMp()`: 获取当前MP
- `obj.sq_GetIntData(skillIndex, dataType)`: 获取技能数据

#### 数据传输
- `obj.sq_StartWrite()`: 开始写入数据
- `obj.sq_WriteDword(value)`: 写入32位整数
- `obj.sq_WriteFloat(value)`: 写入浮点数
- `obj.sq_SendCreatePassiveObjectPacket()`: 发送创建被动对象包

### damager 对象核心方法

#### 伤害设置
- `damager.sq_SetDamageRate(rate)`: 设置伤害倍率
- `damager.sq_SetAttackInfo(type, value)`: 设置攻击信息
- `damager.sq_SetHitInfo(type, value)`: 设置命中信息

#### 状态效果
- `damager.sq_SetChangeStatusIntoAttackInfo()`: 添加状态效果
- `damager.sq_SetKnockInfo()`: 设置击退信息

## 🎮 常用常量定义

### 攻击类型常量
```nut
PHYSICAL_ATTACK <- 0        // 物理攻击
MAGICAL_ATTACK <- 1         // 魔法攻击
PHYSICAL_DEFENSE <- 3       // 物理防御
MAGICAL_DEFENSE <- 2        // 魔法防御
```

### 元素属性常量
```nut
ELEMENT_ATTACK_FIRE <- 42   // 火属性攻击
ELEMENT_ATTACK_WATER <- 43  // 水属性攻击
ELEMENT_ATTACK_DARK <- 44   // 暗属性攻击
ELEMENT_ATTACK_LIGHT <- 45  // 光属性攻击
```

### 状态效果常量
```nut
ACTIVESTATUS_STUCK <- 27           // 硬直状态
ACTIVESTATUS_TOLERANCE_ALL <- 26   // 全抗性增加
DISEASE <- 47                      // 中毒状态
RIGIDITY <- 41                     // 僵直状态
```

### 速度类型常量
```nut
SPEED_TYPE_ATTACK_SPEED <- 10   // 攻击速度
SPEED_TYPE_MOVE_SPEED <- 11     // 移动速度
SPEED_TYPE_CAST_SPEED <- 12     // 施法速度
```

## 🔗 依赖关系

### 文件依赖
- **header.nut**: 状态和技能常量定义
- **chr文件**: 动画序列号对应
- **skill文件**: 技能基础数据
- **passiveobject**: 被动对象创建

### 状态依赖
- STATE定义必须在header.nut中注册
- ANI序列号必须与chr文件对应
- SKILL常量必须与技能代码匹配

## ⚠️ 重要注意事项

1. **状态编号冲突**: STATE定义的编号不能与现有代码冲突
2. **动画序列**: ANI序列号需要比chr文件中的位置减1
3. **函数命名**: 函数名必须与技能名称保持一致
4. **参数类型**: 严格按照函数签名传递参数
5. **内存管理**: 及时清理创建的对象和数据

## 🎯 最佳实践

1. **模块化设计**: 将复杂技能拆分为多个函数
2. **错误检查**: 始终检查对象是否有效
3. **性能优化**: 避免在循环中进行复杂计算
4. **代码复用**: 提取公共逻辑为独立函数
5. **调试支持**: 使用动态调试技术进行开发测试

## 🚀 高级技巧与实战经验

### 动态调试技术

## 🔧 DNF引擎调用机制原理

### 脚本加载机制

#### 入口文件系统
- **loadstate.nut**: DNF脚本加载的核心入口文件
  - 路径: `sqr/loadstate.nut`
  - 功能: 引擎启动时自动预加载，负责后续脚本文件的加载
  - 作用: 类似编程语言中的"头文件/引用包"

#### 脚本运行函数对比

**sq_RunScript() vs dofile()**

| 特性 | sq_RunScript() | dofile() |
|------|----------------|----------|
| 用途 | 加载游戏封包内的.nut脚本 | 加载文件系统中的.nut脚本 |
| 路径规则 | 基于游戏资源目录的相对路径 | 绝对路径或项目相对路径 |
| 读取速度 | 内存封包读取，速度快 | 依赖磁盘I/O，速度较慢 |
| 修改生效 | 需重新打包PVF文件 | 实时生效，无需额外操作 |
| 适用场景 | 成品脚本（追求性能） | 开发/测试阶段（方便调试） |

### 脚本加载策略

#### pushScriptFiles vs pushState

**pushScriptFiles（预加载策略）**
- 加载方式: 全局预加载，类似"全局变量"
- 内存开销: 始终占用内存，开销较大
- 触发方式: 需开发者手动检测状态ID
- 适用场景: 逻辑通用、需全局复用的脚本

**pushState（动态加载策略）**
- 加载方式: 状态触发时动态加载
- 内存开销: 仅状态激活时占用内存，效率高
- 触发方式: 检测到指定状态后引擎自动调用
- 适用场景: 特定状态触发的脚本（如技能释放）

### DNF引擎双轨触发机制

#### 第一轨：函数签名驱动机制（主要方式）

**核心原理**
- 引擎通过预定义的函数名模式扫描全局已加载脚本
- 函数存在且签名匹配时，无需注册即可自动调用
- 与函数所在文件位置无关

**识别规则**
- 函数名格式: "事件前缀 + 角色/场景标识"
- 触发条件: 对应游戏事件发生

**常用函数签名模式**
```nut
// 技能释放后触发
function useSkill_after_职业名(obj, skill, damager)

// 角色受伤时触发  
function onDamage_职业名(obj, damager, damage)

// 全局状态开始时回调
function onStateStart(obj, state, datas)

// 状态更新时触发
function onSetState_职业名(obj, state, datas)

// 攻击命中时触发
function onAttack_职业名(obj, damager, target)
```

#### 第二轨：状态注册驱动机制（辅助方式）

**核心原理**
- 需先通过pushState建立"状态ID与脚本"的映射关系
- 仅当指定状态激活时，引擎才会调用对应函数
- 属于"依赖注册的定向触发"

**注册语法**
```nut
IRDSQRCharacter.pushState(
    职业枚举,           // 指定职业
    "脚本文件路径",      // 脚本文件路径
    "函数前缀",         // 函数前缀
    状态类型,           // 处理的状态类型
    优先级              // 优先级（-1为默认）
);
```

**自动调用规则**
| 函数格式 | 触发时机 | 说明 |
|----------|----------|------|
| onStart_前缀 | 状态开始时 | 状态初始化 |
| proc_前缀 | 状态持续中 | 每帧更新 |
| onEnd_前缀 | 状态结束时 | 状态清理 |
| onAfterSetState_前缀 | 状态设置完成后 | 状态后处理 |

### 引擎调用机制最佳实践

#### 开发阶段建议
1. **加载函数选择**
   - 开发/测试: 使用dofile()（实时生效，方便调试）
   - 成品脚本: 改用sq_RunScript()（提升性能）

2. **加载策略选择**
   - 通用逻辑: 使用pushScriptFiles（全局预加载）
   - 特定状态: 使用pushState（动态加载，节省内存）

3. **函数命名规范**
   - 严格遵循"事件前缀 + 职业名"格式
   - 避免引擎无法识别函数签名

#### 性能优化要点
1. **内存管理**: 优先使用pushState减少内存占用
2. **响应速度**: 函数签名驱动比手动检测更快
3. **文件组织**: 相关功能的脚本文件集中管理

#### 常见陷阱避免
1. **状态匹配**: 状态注册时的状态类型需与技能index匹配
2. **函数签名**: 函数名拼写错误会导致引擎无法识别
3. **文件路径**: 注意相对路径和绝对路径的区别

### 动态调试技术
基于DAF学院教程的动态调试方法，可以实现不重启游戏的实时调试：

```nut
// 在技能函数中调用外部文件
function onSetState_WindStrike(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 动态加载外部调试文件
    dofile(`test.nut`);
    
    // 调用外部定义的函数
    setStateWindStrike(obj);
}
```

**外部test.nut文件**：
```nut
function setStateWindStrike(obj)
{
    // 在这里编写实际的技能逻辑
    // 修改此文件后无需重启游戏即可生效
    obj.sq_SetCurrentAnimation(ANIMATION_WINDSTRIKE);
    obj.sq_StopMove();
}
```

### 函数合并技巧
当多个MOD使用相同的回调函数时，需要进行函数合并：

#### 合并前（冲突）：
```nut
// MOD A
function drawCustomUI_Swordman(obj)
{
    drawBloodBar(obj);
}

// MOD B
function drawCustomUI_Swordman(obj)
{
    drawSkillCooldown(obj);
}
```

#### 合并后（正确）：
```nut
function drawCustomUI_Swordman(obj)
{
    // 合并所有功能
    drawBloodBar(obj);
    drawSkillCooldown(obj);
}
```

### 多动作技能实现
复杂技能通常需要多个动作状态：

```nut
// 状态定义
STATE_SKILL_READY <- 100    // 准备状态
STATE_SKILL_CAST <- 101     // 施法状态
STATE_SKILL_ATTACK <- 102   // 攻击状态
STATE_SKILL_END <- 103      // 结束状态

function onSetState_ComplexSkill(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    switch(state)
    {
        case STATE_SKILL_READY:
            obj.sq_SetCurrentAnimation(ANI_SKILL_READY);
            obj.sq_AddSetStatePacket(STATE_SKILL_CAST, STATE_PRIORITY_USER, true);
            break;
            
        case STATE_SKILL_CAST:
            obj.sq_SetCurrentAnimation(ANI_SKILL_CAST);
            // 设置施法时间
            obj.sq_SetStaticSpeedInfo(SPEED_TYPE_CAST_SPEED, 
                SPEED_TYPE_CAST_SPEED, SPEED_VALUE_DEFAULT, 
                SPEED_VALUE_DEFAULT, 1.0, 1.0);
            break;
            
        case STATE_SKILL_ATTACK:
            obj.sq_SetCurrentAnimation(ANI_SKILL_ATTACK);
            // 创建攻击判定
            createAttackArea(obj);
            break;
            
        case STATE_SKILL_END:
            obj.sq_SetCurrentAnimation(ANI_SKILL_END);
            obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, true);
            break;
    }
}
```

### 强制中断与共存技巧
实现技能的强制中断和共存机制：

```nut
function checkCommandEnable_ForceSkill(obj)
{
    if(!obj) return false;
    
    // 检查是否可以强制中断当前状态
    local currentState = obj.sq_GetState();
    
    // 允许中断的状态列表
    local interruptableStates = [
        STATE_STAND,
        STATE_WALK,
        STATE_RUN,
        STATE_ATTACK  // 可以中断普通攻击
    ];
    
    // 检查当前状态是否可中断
    foreach(state in interruptableStates)
    {
        if(currentState == state)
            return true;
    }
    
    return false;
}
```

### 属性计算与加成
实现复杂的属性计算和技能加成：

```nut
function calculateSkillDamage(obj, skillLevel)
{
    if(!obj) return 0;
    
    // 基础伤害
    local baseDamage = obj.sq_GetIntData(SKILL_SKILLNAME, SKL_BASIC_DAMAGE);
    
    // 技能等级加成
    local levelBonus = skillLevel * 50;
    
    // 获取角色属性
    local physicalAttack = obj.sq_GetBonusRateWithPassive(PHYSICAL_ATTACK);
    local magicalAttack = obj.sq_GetBonusRateWithPassive(MAGICAL_ATTACK);
    
    // 计算最终伤害
    local finalDamage = (baseDamage + levelBonus) * (physicalAttack + magicalAttack) / 100;
    
    return finalDamage.tointeger();
}
```

### 特效与音效管理
统一管理技能的视觉和音效效果：

```nut
function createSkillEffects(obj, effectType)
{
    if(!obj) return;
    
    switch(effectType)
    {
        case EFFECT_CAST:
            // 施法特效
            obj.sq_StartWrite();
            obj.sq_WriteDword(EFFECT_CAST_ID);
            obj.sq_SendCreatePassiveObjectPacket(24210, 0, 0, 0, 0);
            
            // 施法音效
            obj.sq_PlaySound(`SKILL_CAST_SOUND`);
            break;
            
        case EFFECT_HIT:
            // 命中特效
            obj.sq_StartWrite();
            obj.sq_WriteDword(EFFECT_HIT_ID);
            obj.sq_SendCreatePassiveObjectPacket(24211, 0, 0, 0, 0);
            
            // 命中音效
            obj.sq_PlaySound(`SKILL_HIT_SOUND`);
            break;
    }
}
```

### 性能优化技巧

#### 1. 减少不必要的计算
```nut
// 不好的做法
function proc_BadExample(appendage)
{
    local obj = appendage.getParent();
    if(!obj) return;
    
    // 每帧都进行复杂计算
    local damage = calculateComplexDamage(obj);
    obj.sq_SetDamage(damage);
}

// 好的做法
function proc_GoodExample(appendage)
{
    local obj = appendage.getParent();
    if(!obj) return;
    
    // 只在需要时计算
    if(appendage.getTimer() % 30 == 0) // 每30帧计算一次
    {
        local damage = calculateComplexDamage(obj);
        appendage.setVar(`cachedDamage`, damage);
    }
    
    local damage = appendage.getVar(`cachedDamage`);
    obj.sq_SetDamage(damage);
}
```

#### 2. 合理使用AP生命周期
```nut
function onStart_OptimizedAP(appendage)
{
    if(!appendage) return;
    
    // 设置合理的AP持续时间
    appendage.sq_SetValidTime(5000); // 5秒后自动清理
    
    // 初始化缓存数据
    appendage.setVar(`initialized`, true);
}

function isEnd_OptimizedAP(appendage)
{
    if(!appendage) return true;
    
    local obj = appendage.getParent();
    if(!obj) return true;
    
    // 检查对象状态，及时清理无效AP
    if(obj.sq_GetHp() <= 0) return true;
    
    return false;
}
```

### 调试与错误处理

#### 1. 调试信息输出
```nut
function debugLog(message)
{
    // 在开发阶段输出调试信息
    if(DEBUG_MODE)
    {
        print(`[DEBUG] ` + message);
    }
}

function onSetState_DebugSkill(obj, state, datas, isResetTimer)
{
    debugLog(`Setting state: ` + state + ` for object: ` + obj);
    
    // 实际技能逻辑
    // ...
}
```

#### 2. 错误恢复机制
```nut
function safeExecuteSkill(obj, skillFunction)
{
    try
    {
        skillFunction(obj);
    }
    catch(error)
    {
        // 错误处理：恢复到安全状态
        if(obj)
        {
            obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, true);
        }
        
        debugLog(`Skill execution error: ` + error);
    }
}
```

## 📚 实战案例参考

### 案例1：冰霜穿刺技能
```nut
// 基于DAF教程的冰霜穿刺实现
STATE_ICE_PIERCE <- 150

function checkExecutableSkill_IcePierce(obj)
{
    if(!obj) return false;
    if(obj.sq_GetMp() < 50) return false;
    if(obj.sq_IsUseSkill(SKILL_ICE_PIERCE)) return false;
    return true;
}

function onSetState_IcePierce(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    obj.sq_SetCurrentAnimation(ANI_ICE_PIERCE);
    obj.sq_StopMove();
    obj.sq_AddMp(-50);
    obj.sq_UseSkill(SKILL_ICE_PIERCE, true);
}

function onKeyFrameFlag_IcePierce(obj, flagIndex)
{
    if(!obj) return;
    
    if(flagIndex == 1)
    {
        // 创建冰霜穿刺效果
        obj.sq_StartWrite();
        obj.sq_WriteDword(1); // 穿刺方向
        obj.sq_SendCreatePassiveObjectPacket(24300, 0, 0, 0, 0);
    }
}
```

### 案例2：BUFF技能实现
```nut
// 基于DAF教程的BUFF技能
function onSetState_PowerBuff(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 应用BUFF效果
    sq_AppendAppendage(obj, obj, APPENDAGE_POWER_BUFF, true, `power_buff.ap`, true);
    
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, true);
}
```

---

*此文档基于DNF NUT脚本系统设计，融合DAF学院教程精华，专注于AI深度理解和实际应用*