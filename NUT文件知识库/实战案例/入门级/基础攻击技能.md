# 基础攻击技能实战案例

## 📖 案例概述

本案例演示如何创建一个最基础的主动攻击技能，包含完整的技能流程：施法前摇、攻击判定、伤害计算、施法后摇。这是学习NUT脚本的第一步，掌握了基础攻击技能的实现，就能理解NUT脚本的核心工作原理。

## 🎯 学习目标

- 理解NUT脚本的基本结构
- 掌握技能状态的切换流程
- 学会基础的攻击判定实现
- 了解伤害计算的基本方法
- 熟悉常用的NUT函数调用

## 📋 技能需求

**技能名称：** 基础斩击  
**技能类型：** 主动攻击技能  
**施法时间：** 0.3秒前摇 + 0.2秒后摇  
**攻击范围：** 前方200像素矩形区域  
**伤害倍率：** 150%物理攻击力  
**冷却时间：** 3秒  

## 🔧 完整实现

### 技能主文件 (skill_basic_attack.nut)

```nut
// =====================================
// 基础斩击技能 - 完整实现
// 作者：NUT脚本教程
// 版本：1.0
// =====================================

// 技能配置常量
const SKILL_ID = 1001;                    // 技能ID
const CAST_TIME = 300;                    // 施法时间(毫秒)
const RECOVERY_TIME = 200;                // 后摇时间(毫秒)
const ATTACK_RANGE_X = 200;               // 攻击范围X
const ATTACK_RANGE_Y = 100;               // 攻击范围Y
const DAMAGE_RATE = 1.5;                  // 伤害倍率
const COOLDOWN_TIME = 3000;               // 冷却时间(毫秒)

// =====================================
// 技能检查函数 - 判断是否可以释放技能
// =====================================
function checkExecutableSkill_BasicAttack(obj)
{
    // 检查对象有效性
    if (!obj || obj.isObjectType(OBJECTTYPE_ACTIVE) == false)
        return false;
    
    // 检查角色状态 - 不能在僵直、浮空、倒地时释放
    if (obj.getState() == STATE_STUN || 
        obj.getState() == STATE_FLOAT || 
        obj.getState() == STATE_DOWN)
        return false;
    
    // 检查MP消耗 (假设消耗20MP)
    if (obj.getMp() < 20)
        return false;
    
    // 检查技能冷却
    if (obj.isSkillCoolTime(SKILL_ID) == true)
        return false;
    
    return true;  // 所有检查通过，可以释放技能
}

// =====================================
// 技能释放函数 - 技能的主要逻辑入口
// =====================================
function onSetSkill_BasicAttack(obj, skillIndex, datas)
{
    // 验证对象有效性
    if (!obj) return;
    
    // 消耗MP
    obj.addMp(-20);
    
    // 设置技能冷却
    obj.setSkillCoolTime(SKILL_ID, COOLDOWN_TIME);
    
    // 进入施法状态
    obj.setState(STATE_SKILL);
    
    // 播放施法动画 (假设动画序列为0)
    obj.setCurrentAnimation(0);
    
    // 设置施法时间
    obj.setCurrentSkillPhase(0);  // 第0阶段：施法前摇
    obj.setSkillPhaseStartTime(getTimer());
    
    // 创建技能数据存储
    local skillData = {
        startTime = getTimer(),           // 技能开始时间
        phase = 0,                       // 当前阶段 (0:前摇, 1:攻击, 2:后摇)
        hasAttacked = false              // 是否已经进行攻击判定
    };
    
    // 将数据存储到角色对象中
    obj.setData("BasicAttack_Data", skillData);
    
    // 播放施法音效
    obj.playSound("skill_cast.wav");
}

// =====================================
// 技能状态更新函数 - 每帧调用
// =====================================
function onSetState_BasicAttack(obj, state, datas, isResetTimer)
{
    // 只处理技能状态
    if (state != STATE_SKILL) return;
    
    // 获取技能数据
    local skillData = obj.getData("BasicAttack_Data");
    if (!skillData) return;
    
    local currentTime = getTimer();
    local elapsedTime = currentTime - skillData.startTime;
    
    // 根据当前阶段处理不同逻辑
    switch (skillData.phase)
    {
        case 0:  // 施法前摇阶段
            handleCastPhase(obj, skillData, elapsedTime);
            break;
            
        case 1:  // 攻击判定阶段
            handleAttackPhase(obj, skillData, elapsedTime);
            break;
            
        case 2:  // 施法后摇阶段
            handleRecoveryPhase(obj, skillData, elapsedTime);
            break;
    }
}

// =====================================
// 施法前摇阶段处理
// =====================================
function handleCastPhase(obj, skillData, elapsedTime)
{
    // 检查是否完成施法前摇
    if (elapsedTime >= CAST_TIME)
    {
        // 进入攻击阶段
        skillData.phase = 1;
        
        // 切换到攻击动画 (假设动画序列为1)
        obj.setCurrentAnimation(1);
        
        // 播放攻击音效
        obj.playSound("skill_attack.wav");
        
        // 立即进行攻击判定
        performAttack(obj);
        skillData.hasAttacked = true;
    }
}

// =====================================
// 攻击判定阶段处理
// =====================================
function handleAttackPhase(obj, skillData, elapsedTime)
{
    // 攻击阶段很短，主要是播放攻击动画
    // 实际攻击判定在进入此阶段时就完成了
    
    // 检查是否进入后摇阶段 (攻击后立即进入后摇)
    if (elapsedTime >= CAST_TIME + 50)  // 攻击阶段持续50毫秒
    {
        skillData.phase = 2;
        
        // 切换到后摇动画 (假设动画序列为2)
        obj.setCurrentAnimation(2);
    }
}

// =====================================
// 施法后摇阶段处理
// =====================================
function handleRecoveryPhase(obj, skillData, elapsedTime)
{
    // 检查是否完成整个技能
    if (elapsedTime >= CAST_TIME + 50 + RECOVERY_TIME)
    {
        // 技能结束，返回正常状态
        obj.setState(STATE_NORMAL);
        
        // 清理技能数据
        obj.setData("BasicAttack_Data", null);
        
        // 恢复默认动画
        obj.setCurrentAnimation(-1);  // -1表示默认动画
    }
}

// =====================================
// 攻击判定函数 - 核心攻击逻辑
// =====================================
function performAttack(obj)
{
    // 获取角色位置和朝向
    local x = obj.getXPos();
    local y = obj.getYPos();
    local z = obj.getZPos();
    local direction = obj.getDirection();  // 0=右, 1=左
    
    // 计算攻击区域
    local attackX = x;
    local attackY = y;
    
    // 根据朝向调整攻击位置
    if (direction == 0)  // 面向右
        attackX += ATTACK_RANGE_X / 2;
    else  // 面向左
        attackX -= ATTACK_RANGE_X / 2;
    
    // 创建攻击区域
    local attackArea = sq_CreateDrawOnlyObject(obj, "character/swordman/effect/basicattack.ani", 
                                               LAYER_BOTTOM, true);
    if (attackArea)
    {
        // 设置攻击区域位置
        attackArea.setXPos(attackX);
        attackArea.setYPos(attackY);
        attackArea.setZPos(z);
        
        // 设置攻击区域大小
        attackArea.setSize(ATTACK_RANGE_X, ATTACK_RANGE_Y, 50);
        
        // 设置攻击属性
        setupAttackProperties(obj, attackArea);
        
        // 设置攻击区域生存时间 (100毫秒)
        attackArea.setTimeEvent(0, 100, 1, false);
    }
    
    // 查找攻击范围内的敌人
    local enemies = sq_GetObjectsInRange(obj, attackX, attackY, z, 
                                        ATTACK_RANGE_X, ATTACK_RANGE_Y, 50);
    
    // 对每个敌人造成伤害
    foreach (enemy in enemies)
    {
        if (isValidTarget(obj, enemy))
        {
            dealDamageToEnemy(obj, enemy);
        }
    }
}

// =====================================
// 设置攻击属性
// =====================================
function setupAttackProperties(attacker, attackArea)
{
    // 设置攻击者
    attackArea.setAttacker(attacker);
    
    // 设置攻击类型为物理攻击
    attackArea.setAttackType(ATTACKTYPE_PHYSICAL);
    
    // 设置元素属性为无属性
    attackArea.setElementType(ELEMENT_NONE);
    
    // 设置攻击等级 (影响命中率)
    attackArea.setAttackLevel(attacker.getLevel());
    
    // 设置暴击率
    attackArea.setCriticalRate(attacker.getCriticalRate());
    
    // 设置攻击力
    local damage = attacker.getPhysicalAttack() * DAMAGE_RATE;
    attackArea.setDamage(damage.tointeger());
}

// =====================================
// 验证攻击目标
// =====================================
function isValidTarget(attacker, target)
{
    // 检查目标有效性
    if (!target || target == attacker)
        return false;
    
    // 检查目标是否为敌人
    if (target.getTeam() == attacker.getTeam())
        return false;
    
    // 检查目标是否存活
    if (target.getHp() <= 0)
        return false;
    
    // 检查目标是否在无敌状态
    if (target.isInvincible())
        return false;
    
    return true;
}

// =====================================
// 对敌人造成伤害
// =====================================
function dealDamageToEnemy(attacker, enemy)
{
    // 计算最终伤害
    local baseDamage = attacker.getPhysicalAttack() * DAMAGE_RATE;
    local finalDamage = calculateFinalDamage(attacker, enemy, baseDamage);
    
    // 造成伤害
    enemy.addHp(-finalDamage);
    
    // 显示伤害数字
    enemy.showDamage(finalDamage, DAMAGE_TYPE_PHYSICAL);
    
    // 播放受击音效
    enemy.playSound("hit_sound.wav");
    
    // 添加受击效果
    addHitEffect(enemy);
    
    // 检查是否击杀
    if (enemy.getHp() <= 0)
    {
        // 播放击杀音效
        attacker.playSound("kill_sound.wav");
        
        // 给攻击者加经验
        attacker.addExp(enemy.getLevel() * 10);
    }
}

// =====================================
// 计算最终伤害 (考虑防御、抗性等)
// =====================================
function calculateFinalDamage(attacker, target, baseDamage)
{
    // 获取目标防御力
    local defense = target.getPhysicalDefense();
    
    // 简单的伤害计算公式
    local finalDamage = baseDamage * 100 / (100 + defense);
    
    // 随机浮动 (±10%)
    local randomFactor = 0.9 + (rand() % 21) * 0.01;  // 0.9 ~ 1.1
    finalDamage *= randomFactor;
    
    // 确保最小伤害为1
    if (finalDamage < 1)
        finalDamage = 1;
    
    return finalDamage.tointeger();
}

// =====================================
// 添加受击特效
// =====================================
function addHitEffect(target)
{
    // 创建受击特效
    local hitEffect = sq_CreateDrawOnlyObject(target, "character/common/effect/hit.ani", 
                                             LAYER_TOP, true);
    if (hitEffect)
    {
        // 设置特效位置
        hitEffect.setXPos(target.getXPos());
        hitEffect.setYPos(target.getYPos() + 50);  // 稍微偏上
        hitEffect.setZPos(target.getZPos());
        
        // 设置特效生存时间
        hitEffect.setTimeEvent(0, 300, 1, false);  // 300毫秒后消失
    }
    
    // 添加屏幕震动效果
    sq_ShakeScreen(target, 100, 5, 5);  // 震动100毫秒，强度5x5
}

// =====================================
// 技能中断处理
// =====================================
function onEndCurrentAni_BasicAttack(obj)
{
    // 当动画被强制中断时调用
    // 清理技能数据，避免状态异常
    
    local skillData = obj.getData("BasicAttack_Data");
    if (skillData)
    {
        obj.setData("BasicAttack_Data", null);
        obj.setState(STATE_NORMAL);
    }
}

// =====================================
// 关键帧事件处理 (可选)
// =====================================
function onKeyFrameFlag_BasicAttack(obj, flagIndex)
{
    // 当动画播放到特定关键帧时调用
    // 可以用于精确控制攻击时机
    
    switch (flagIndex)
    {
        case 1:  // 第1个关键帧 - 攻击判定
            local skillData = obj.getData("BasicAttack_Data");
            if (skillData && !skillData.hasAttacked)
            {
                performAttack(obj);
                skillData.hasAttacked = true;
            }
            break;
            
        case 2:  // 第2个关键帧 - 技能结束
            obj.setState(STATE_NORMAL);
            obj.setData("BasicAttack_Data", null);
            break;
    }
}
```

## 📝 代码详解

### 1. 技能检查函数
```nut
function checkExecutableSkill_BasicAttack(obj)
```
- **作用：** 判断角色是否可以释放技能
- **检查项：** 角色状态、MP消耗、技能冷却
- **返回值：** true表示可以释放，false表示不可以

### 2. 技能释放函数
```nut
function onSetSkill_BasicAttack(obj, skillIndex, datas)
```
- **作用：** 技能释放时的初始化逻辑
- **主要操作：** 消耗资源、设置状态、播放动画、存储数据

### 3. 状态更新函数
```nut
function onSetState_BasicAttack(obj, state, datas, isResetTimer)
```
- **作用：** 每帧更新技能状态
- **核心逻辑：** 根据时间和阶段执行不同的处理

### 4. 攻击判定函数
```nut
function performAttack(obj)
```
- **作用：** 执行实际的攻击判定和伤害计算
- **主要步骤：** 创建攻击区域、查找目标、造成伤害

## 🎮 使用方法

### 1. 文件配置
将代码保存为 `skill_basic_attack.nut` 文件，放置在技能目录下。

### 2. 技能配置文件
在对应的 `.skl` 文件中添加：
```
[skill data]
	`skill_basic_attack.nut`
[/skill data]
```

### 3. 动画配置
确保以下动画文件存在：
- 施法动画：序列0
- 攻击动画：序列1  
- 后摇动画：序列2

### 4. 音效配置
准备以下音效文件：
- `skill_cast.wav` - 施法音效
- `skill_attack.wav` - 攻击音效
- `hit_sound.wav` - 受击音效
- `kill_sound.wav` - 击杀音效

## 🔍 常见问题

### Q1: 技能无法释放？
**A:** 检查以下几点：
- `checkExecutableSkill_BasicAttack` 函数是否正确实现
- 角色状态是否正常
- MP是否足够
- 技能是否在冷却中

### Q2: 攻击没有伤害？
**A:** 检查以下几点：
- `performAttack` 函数是否被调用
- 攻击范围设置是否正确
- 目标验证逻辑是否有问题
- 伤害计算是否正确

### Q3: 动画播放异常？
**A:** 检查以下几点：
- 动画文件是否存在
- 动画序列号是否正确
- 状态切换逻辑是否正确

### Q4: 技能卡死不结束？
**A:** 检查以下几点：
- 时间计算是否正确
- 状态切换条件是否满足
- 是否正确清理技能数据

## 🚀 扩展建议

### 1. 添加技能等级
```nut
// 根据技能等级调整伤害
local skillLevel = obj.getSkillLevel(SKILL_ID);
local damage = attacker.getPhysicalAttack() * (DAMAGE_RATE + skillLevel * 0.1);
```

### 2. 添加连击系统
```nut
// 检查连击次数
local comboCount = obj.getData("ComboCount") || 0;
if (comboCount >= 3)
{
    // 触发特殊效果
    performSpecialAttack(obj);
}
```

### 3. 添加状态效果
```nut
// 给敌人添加减速效果
enemy.addState(STATE_SLOW, 2000);  // 减速2秒
```

### 4. 添加粒子特效
```nut
// 创建粒子特效
local particle = sq_CreateParticle(obj, "effect/slash.ptl");
particle.setXPos(attackX);
particle.setYPos(attackY);
```

## 📚 相关文档

- [标签参考.md](../../标签参考.md) - 查看所有可用的NUT函数
- [问题解答.md](../../问题解答.md) - 常见问题的解决方案
- [BUFF技能.md](./BUFF技能.md) - 学习状态管理技巧
- [多段攻击技能.md](../进阶级/多段攻击技能.md) - 进阶攻击技能实现

---

*这个基础攻击技能案例涵盖了NUT脚本的核心概念，是学习更复杂技能的重要基础。建议反复练习，直到完全理解每个函数的作用和调用时机。*