# NUT脚本伤害计算知识点

## 核心概念

伤害计算是NUT脚本中技能系统的核心部分，负责计算技能对目标造成的最终伤害值。涉及基础伤害、属性加成、暴击、元素、状态修正等多个因素。

## 基本原理

### 伤害计算公式
```
最终伤害 = (基础攻击力 - 防御力) × 暴击倍率 × 元素倍率 × 状态倍率 × 随机倍率
```

### 伤害类型
- **物理伤害**: 基于物理攻击力和物理防御力
- **魔法伤害**: 基于魔法攻击力和魔法防御力  
- **固定伤害**: 无视防御力的固定数值伤害

## 实现要点

### 基础伤害计算
```nut
function calculateBaseDamage(attacker, skillData)
{
    local attack = 0;
    local damageType = skillData.getData("damage_type");
    
    switch (damageType) {
        case DAMAGE_TYPE_PHYSICAL:
            attack = attacker.getPhysicalAttack();
            break;
        case DAMAGE_TYPE_MAGICAL:
            attack = attacker.getMagicalAttack();
            break;
        case DAMAGE_TYPE_FIXED:
            return skillData.getData("fixed_damage");
    }
    
    // 应用技能倍率
    local damageRate = skillData.getData("damage_rate");
    attack = attack * damageRate / 100;
    
    return attack;
}
```

### 防御力计算
```nut
function calculateDefense(defender, damageType, penetration)
{
    local defense = 0;
    
    switch (damageType) {
        case DAMAGE_TYPE_PHYSICAL:
            defense = defender.getPhysicalDefense();
            break;
        case DAMAGE_TYPE_MAGICAL:
            defense = defender.getMagicalDefense();
            break;
        case DAMAGE_TYPE_FIXED:
            return 0; // 固定伤害无视防御
    }
    
    // 应用穿透
    defense = defense * (100 - penetration) / 100;
    
    return defense;
}
```

### 暴击计算
```nut
function calculateCritical(attacker, defender)
{
    local critRate = attacker.getCriticalRate();
    local critDamage = attacker.getCriticalDamage();
    
    // 暴击判定
    local randomValue = math.rand() % 100;
    if (randomValue < critRate) {
        return critDamage; // 返回暴击倍率
    }
    
    return 100; // 普通攻击倍率100%
}
```

### 元素伤害计算
```nut
function calculateElementDamage(attacker, defender, element)
{
    if (element == ELEMENT_NONE) return 100;
    
    local elementAttack = attacker.getElementAttack(element);
    local elementResist = defender.getElementResist(element);
    
    // 元素伤害加成 = (元素攻击力 - 元素抗性) / 2.5
    local elementBonus = (elementAttack - elementResist) / 2.5;
    elementBonus = math.max(0, elementBonus); // 最小为0
    
    return 100 + elementBonus; // 返回百分比
}
```

### 状态修正计算
```nut
function calculateStateModifier(attacker, defender)
{
    local modifier = 100;
    
    // 检查攻击者增益状态
    if (hasState(attacker, "power_boost")) {
        local boostLevel = getStateLevel(attacker, "power_boost");
        modifier += boostLevel * 10; // 每级增加10%伤害
    }
    
    // 检查防御者减益状态
    if (hasState(defender, "vulnerability")) {
        local vulnLevel = getStateLevel(defender, "vulnerability");
        modifier += vulnLevel * 15; // 每级增加15%受到伤害
    }
    
    return modifier;
}
```

## 完整伤害计算函数

```nut
function calculateFinalDamage(attacker, defender, skillData)
{
    // 1. 获取基础数据
    local damageType = skillData.getData("damage_type");
    local element = skillData.getData("element");
    local penetration = skillData.getData("penetration");
    
    // 2. 计算基础攻击力
    local baseAttack = calculateBaseDamage(attacker, skillData);
    
    // 3. 计算防御力
    local defense = calculateDefense(defender, damageType, penetration);
    
    // 4. 基础伤害 = 攻击力 - 防御力
    local baseDamage = baseAttack - defense;
    baseDamage = math.max(1, baseDamage); // 最小伤害为1
    
    // 5. 计算暴击倍率
    local critMultiplier = calculateCritical(attacker, defender);
    
    // 6. 计算元素倍率
    local elementMultiplier = calculateElementDamage(attacker, defender, element);
    
    // 7. 计算状态修正
    local stateMultiplier = calculateStateModifier(attacker, defender);
    
    // 8. 计算随机浮动 (±5%)
    local randomMultiplier = 95 + (math.rand() % 11); // 95-105
    
    // 9. 最终伤害计算
    local finalDamage = baseDamage * critMultiplier * elementMultiplier * 
                       stateMultiplier * randomMultiplier / 1000000;
    
    return finalDamage.tointeger();
}
```

## 特殊伤害效果

### 穿透伤害
```nut
function applyPenetration(damage, penetrationRate)
{
    // 穿透伤害无视部分防御
    local penetrationDamage = damage * penetrationRate / 100;
    return damage + penetrationDamage;
}
```

### 真实伤害
```nut
function calculateTrueDamage(attacker, skillData)
{
    // 真实伤害无视所有防御和抗性
    local attack = attacker.getPhysicalAttack();
    local damageRate = skillData.getData("damage_rate");
    
    return attack * damageRate / 100;
}
```

### 百分比伤害
```nut
function calculatePercentDamage(target, percentage)
{
    // 基于目标当前/最大生命值的百分比伤害
    local maxHP = target.getMaxHP();
    return maxHP * percentage / 100;
}
```

## 伤害应用

### 基础伤害应用
```nut
function applyDamage(target, damage, attacker, skillData)
{
    // 检查目标是否有效
    if (!target || target.isDead()) return;
    
    // 应用伤害
    target.addHP(-damage);
    
    // 触发受击事件
    target.onTakeDamage(damage, attacker, skillData);
    
    // 显示伤害数字
    showDamageNumber(target, damage);
}
```

### 带特效的伤害应用
```nut
function applyDamageWithEffects(target, damage, attacker, skillData)
{
    // 基础伤害
    applyDamage(target, damage, attacker, skillData);
    
    // 特殊效果
    local effects = skillData.getData("special_effects");
    
    foreach (effect in effects) {
        switch (effect) {
            case "knockback":
                applyKnockback(target, attacker);
                break;
            case "stun":
                applyStun(target, 2000); // 2秒眩晕
                break;
            case "burn":
                applyBurnEffect(target, damage / 10, 5000); // 持续燃烧
                break;
        }
    }
}
```

## 常用常量定义

```nut
// 伤害类型
const DAMAGE_TYPE_PHYSICAL = 0;
const DAMAGE_TYPE_MAGICAL = 1;
const DAMAGE_TYPE_FIXED = 2;
const DAMAGE_TYPE_TRUE = 3;

// 元素类型
const ELEMENT_NONE = 0;
const ELEMENT_FIRE = 1;
const ELEMENT_ICE = 2;
const ELEMENT_LIGHT = 3;
const ELEMENT_DARK = 4;

// 暴击类型
const CRITICAL_NORMAL = 150;    // 普通暴击150%
const CRITICAL_DEADLY = 200;    // 致命暴击200%
const CRITICAL_CRUSHING = 250;  // 粉碎暴击250%
```

## 最佳实践

### 1. 性能优化
- 缓存计算结果，避免重复计算
- 使用整数运算，避免浮点数精度问题
- 合理设置随机数范围

### 2. 数值平衡
- 设置合理的伤害上下限
- 考虑不同等级间的数值差距
- 平衡不同伤害类型的效果

### 3. 错误处理
```nut
function safeDamageCalculation(attacker, defender, skillData)
{
    // 参数验证
    if (!attacker || !defender || !skillData) {
        return 0;
    }
    
    // 异常处理
    try {
        return calculateFinalDamage(attacker, defender, skillData);
    } catch (e) {
        print("伤害计算错误: " + e);
        return 1; // 返回最小伤害
    }
}
```

### 4. 调试支持
```nut
function debugDamageCalculation(attacker, defender, skillData)
{
    print("=== 伤害计算调试 ===");
    print("攻击者: " + attacker.getName());
    print("防御者: " + defender.getName());
    print("基础攻击力: " + calculateBaseDamage(attacker, skillData));
    print("防御力: " + calculateDefense(defender, skillData.getData("damage_type"), 0));
    print("最终伤害: " + calculateFinalDamage(attacker, defender, skillData));
}


    

    
    // =====================================
    // 应用攻击力加成
    // =====================================
    function applyAttackPower(damageData)
    {
        local attacker = damageData.attacker;
        local attackPower = 0;
        local attackRate = 1.0;
        
        // 根据伤害类型获取对应攻击力
        switch (damageData.damageType)
        {
            case DAMAGE_TYPE_PHYSICAL:
                attackPower = attacker.getPhysicalAttack();
                attackRate = attacker.getPhysicalAttackRate();
                break;
                
            case DAMAGE_TYPE_MAGICAL:
                attackPower = attacker.getMagicalAttack();
                attackRate = attacker.getMagicalAttackRate();
                break;
                
            case DAMAGE_TYPE_TRUE:
                // 真实伤害不受攻击力影响
                return;
                
            case DAMAGE_TYPE_MIXED:
                // 混合伤害取两者平均值
                local physicalAttack = attacker.getPhysicalAttack() * attacker.getPhysicalAttackRate();
                local magicalAttack = attacker.getMagicalAttack() * attacker.getMagicalAttackRate();
                attackPower = (physicalAttack + magicalAttack) / 2;
                attackRate = 1.0;
                break;
        }
        
        // 应用攻击力
        local oldDamage = damageData.finalDamage;
        damageData.finalDamage = damageData.baseDamage * attackRate + attackPower;
        
        // 记录修正信息
        damageData.modifiers.append({
            type = "AttackPower",
            oldValue = oldDamage,
            newValue = damageData.finalDamage,
            modifier = attackPower,
            rate = attackRate
        });
        
        if (this.config.debugMode)
        {
            damageData.debugInfo.append("攻击力加成: " + oldDamage + " -> " + damageData.finalDamage);
        }
    }
    
    // =====================================
    // 应用防御力减免
    // =====================================
    function applyDefense(damageData)
    {
        // 真实伤害无视防御
        if (damageData.damageType == DAMAGE_TYPE_TRUE)
            return;
        
        local target = damageData.target;
        local defense = 0;
        local defenseRate = 1.0;
        
        // 根据伤害类型获取对应防御力
        switch (damageData.damageType)
        {
            case DAMAGE_TYPE_PHYSICAL:
                defense = target.getPhysicalDefense();
                defenseRate = target.getPhysicalDefenseRate();
                break;
                
            case DAMAGE_TYPE_MAGICAL:
                defense = target.getMagicalDefense();
                defenseRate = target.getMagicalDefenseRate();
                break;
                
            case DAMAGE_TYPE_MIXED:
                // 混合伤害取两者平均值
                local physicalDefense = target.getPhysicalDefense() * target.getPhysicalDefenseRate();
                local magicalDefense = target.getMagicalDefense() * target.getMagicalDefenseRate();
                defense = (physicalDefense + magicalDefense) / 2;
                defenseRate = 1.0;
                break;
        }
        
        // 计算防御减免
        local oldDamage = damageData.finalDamage;
        local totalDefense = defense * defenseRate;
        
        // 使用经典的防御公式：伤害 = 伤害 * 100 / (100 + 防御)
        damageData.finalDamage = damageData.finalDamage * 100 / (100 + totalDefense);
        
        // 记录修正信息
        damageData.modifiers.append({
            type = "Defense",
            oldValue = oldDamage,
            newValue = damageData.finalDamage,
            defense = totalDefense,
            reduction = (oldDamage - damageData.finalDamage) / oldDamage
        });
        
        if (this.config.debugMode)
        {
            damageData.debugInfo.append("防御减免: " + oldDamage + " -> " + damageData.finalDamage + " (防御:" + totalDefense + ")");
        }
    }
    
    // =====================================
    // 应用暴击系统
    // =====================================
    function applyCritical(damageData)
    {
        if (!this.config.enableCritical)
            return;
        
        local attacker = damageData.attacker;
        local criticalRate = attacker.getCriticalRate();
        local criticalDamage = attacker.getCriticalDamage();
        
        // 检查是否暴击
        local randomValue = rand() % 10000;  // 0-9999
        if (randomValue < criticalRate * 100)  // 暴击率转换为万分比
        {
            damageData.isCritical = true;
            
            // 确定暴击类型
            if (randomValue < criticalRate * 10)  // 1%概率完美暴击
            {
                damageData.criticalType = CRITICAL_TYPE_PERFECT;
                criticalDamage *= 1.5;  // 完美暴击额外50%伤害
            }
            else if (randomValue < criticalRate * 50)  // 5%概率致命暴击
            {
                damageData.criticalType = CRITICAL_TYPE_DEADLY;
                criticalDamage *= 1.2;  // 致命暴击额外20%伤害
            }
            
            // 应用暴击伤害
            local oldDamage = damageData.finalDamage;
            damageData.finalDamage *= criticalDamage;
            
            // 记录修正信息
            damageData.modifiers.append({
                type = "Critical",
                oldValue = oldDamage,
                newValue = damageData.finalDamage,
                criticalType = damageData.criticalType,
                multiplier = criticalDamage
            });
            
            if (this.config.debugMode)
            {
                local typeText = ["普通", "致命", "完美"][damageData.criticalType];
                damageData.debugInfo.append(typeText + "暴击: " + oldDamage + " -> " + damageData.finalDamage);
            }
        }
    }
    
    // =====================================
    // 应用元素系统
    // =====================================
    function applyElemental(damageData)
    {
        if (!this.config.enableElemental || damageData.elementType == ELEMENT_NONE)
            return;
        
        local attacker = damageData.attacker;
        local target = damageData.target;
        
        // 获取元素强化
        local elementalPower = this.getElementalPower(attacker, damageData.elementType);
        local elementalResistance = this.getElementalResistance(target, damageData.elementType);
        
        // 计算元素相克
        local elementalMultiplier = this.getElementalMultiplier(damageData.elementType, target);
        
        // 应用元素效果
        local oldDamage = damageData.finalDamage;
        
        // 元素强化加成
        damageData.finalDamage += elementalPower;
        
        // 元素抗性减免
        damageData.finalDamage *= (1.0 - elementalResistance);
        
        // 元素相克倍率
        damageData.finalDamage *= elementalMultiplier;
        
        // 记录修正信息
        damageData.modifiers.append({
            type = "Elemental",
            oldValue = oldDamage,
            newValue = damageData.finalDamage,
            elementType = damageData.elementType,
            power = elementalPower,
            resistance = elementalResistance,
            multiplier = elementalMultiplier
        });
        
        if (this.config.debugMode)
        {
            local elementNames = ["无", "火", "冰", "雷", "暗"];
            damageData.debugInfo.append(elementNames[damageData.elementType] + "元素: " + oldDamage + " -> " + damageData.finalDamage);
        }
        
        // 应用元素状态效果
        this.applyElementalEffects(damageData);
    }
    
    // =====================================
    // 获取元素强化值
    // =====================================
    function getElementalPower(obj, elementType)
    {
        switch (elementType)
        {
            case ELEMENT_FIRE:
                return obj.getData("FirePower") || 0;
            case ELEMENT_ICE:
                return obj.getData("IcePower") || 0;
            case ELEMENT_LIGHTNING:
                return obj.getData("LightningPower") || 0;
            case ELEMENT_DARK:
                return obj.getData("DarkPower") || 0;
            default:
                return 0;
        }
    }
    
    // =====================================
    // 获取元素抗性值
    // =====================================
    function getElementalResistance(obj, elementType)
    {
        switch (elementType)
        {
            case ELEMENT_FIRE:
                return (obj.getData("FireResistance") || 0) / 100.0;
            case ELEMENT_ICE:
                return (obj.getData("IceResistance") || 0) / 100.0;
            case ELEMENT_LIGHTNING:
                return (obj.getData("LightningResistance") || 0) / 100.0;
            case ELEMENT_DARK:
                return (obj.getData("DarkResistance") || 0) / 100.0;
            default:
                return 0.0;
        }
    }
    
    // =====================================
    // 获取元素相克倍率
    // =====================================
    function getElementalMultiplier(attackElement, target)
    {
        // 获取目标的主要元素属性
        local targetElement = target.getData("MainElement") || ELEMENT_NONE;
        
        if (targetElement == ELEMENT_NONE || attackElement == ELEMENT_NONE)
            return 1.0;
        
        // 查找相克关系
        if (attackElement in this.elementalChart)
        {
            local chart = this.elementalChart[attackElement];
            if (targetElement in chart)
            {
                return chart[targetElement];
            }
        }
        
        return 1.0;  // 无相克关系
    }
    
    // =====================================
    // 应用元素状态效果
    // =====================================
    function applyElementalEffects(damageData)
    {
        local target = damageData.target;
        local elementType = damageData.elementType;
        local damage = damageData.finalDamage;
        
        // 根据元素类型应用不同效果
        switch (elementType)
        {
            case ELEMENT_FIRE:
                // 火元素：燃烧效果
                if (rand() % 100 < 20)  // 20%概率
                {
                    this.applyBurnEffect(target, damage * 0.1, 3000);  // 3秒燃烧
                }
                break;
                
            case ELEMENT_ICE:
                // 冰元素：冰冻效果
                if (rand() % 100 < 15)  // 15%概率
                {
                    this.applyFreezeEffect(target, 1500);  // 1.5秒冰冻
                }
                break;
                
            case ELEMENT_LIGHTNING:
                // 雷元素：麻痹效果
                if (rand() % 100 < 25)  // 25%概率
                {
                    this.applyParalyzeEffect(target, 2000);  // 2秒麻痹
                }
                break;
                
            case ELEMENT_DARK:
                // 暗元素：诅咒效果
                if (rand() % 100 < 10)  // 10%概率
                {
                    this.applyCurseEffect(target, 5000);  // 5秒诅咒
                }
                break;
        }
    }
    
    // =====================================
    // 应用状态效果修正
    // =====================================
    function applyStatusEffects(damageData)
    {
        if (!this.config.enableStatusEffects)
            return;
        
        local attacker = damageData.attacker;
        local target = damageData.target;
        local oldDamage = damageData.finalDamage;
        
        // 攻击者的增伤BUFF
        local damageBonus = this.getStatusDamageBonus(attacker);
        damageData.finalDamage *= (1.0 + damageBonus);
        
        // 目标的减伤BUFF
        local damageReduction = this.getStatusDamageReduction(target);
        damageData.finalDamage *= (1.0 - damageReduction);
        
        // 特殊状态处理
        this.applySpecialStatusEffects(damageData);
        
        // 记录修正信息
        if (damageData.finalDamage != oldDamage)
        {
            damageData.modifiers.append({
                type = "StatusEffects",
                oldValue = oldDamage,
                newValue = damageData.finalDamage,
                damageBonus = damageBonus,
                damageReduction = damageReduction
            });
            
            if (this.config.debugMode)
            {
                damageData.debugInfo.append("状态效果: " + oldDamage + " -> " + damageData.finalDamage);
            }
        }
    }
    
    // =====================================
    // 获取状态增伤加成
    // =====================================
    function getStatusDamageBonus(obj)
    {
        local totalBonus = 0.0;
        
        // 检查各种增伤BUFF
        if (obj.getAppendage(BUFF_BERSERK))
            totalBonus += 0.3;  // 狂暴：30%增伤
        
        if (obj.getAppendage(BUFF_FOCUS))
            totalBonus += 0.15;  // 专注：15%增伤
        
        if (obj.getAppendage(BUFF_CRITICAL_UP))
            totalBonus += 0.2;  // 暴击强化：20%增伤
        
        // 检查装备加成
        local equipBonus = obj.getData("EquipDamageBonus") || 0;
        totalBonus += equipBonus / 100.0;
        
        return totalBonus;
    }
    
    // =====================================
    // 获取状态减伤效果
    // =====================================
    function getStatusDamageReduction(obj)
    {
        local totalReduction = 0.0;
        
        // 检查各种减伤BUFF
        if (obj.getAppendage(BUFF_SHIELD))
            totalReduction += 0.5;  // 护盾：50%减伤
        
        if (obj.getAppendage(BUFF_ARMOR))
            totalReduction += 0.25;  // 护甲：25%减伤
        
        if (obj.getAppendage(BUFF_RESISTANCE))
            totalReduction += 0.15;  // 抗性：15%减伤
        
        // 检查DEBUFF
        if (obj.getAppendage(DEBUFF_VULNERABLE))
            totalReduction -= 0.3;  // 易伤：增加30%受伤
        
        // 确保减伤不超过90%
        if (totalReduction > 0.9)
            totalReduction = 0.9;
        
        return totalReduction;
    }
    
    // =====================================
    // 应用特殊状态效果
    // =====================================
    function applySpecialStatusEffects(damageData)
    {
        local attacker = damageData.attacker;
        local target = damageData.target;
        
        // 吸血效果
        if (attacker.getAppendage(BUFF_LIFESTEAL))
        {
            local healAmount = damageData.finalDamage * 0.2;  // 20%吸血
            attacker.addHp(healAmount);
            
            // 显示治疗数字
            attacker.showHeal(healAmount);
        }
        
        // 反伤效果
        if (target.getAppendage(BUFF_THORNS))
        {
            local reflectDamage = damageData.finalDamage * 0.15;  // 15%反伤
            attacker.addHp(-reflectDamage);
            
            // 显示反伤数字
            attacker.showDamage(reflectDamage, DAMAGE_TYPE_REFLECT);
        }
        
        // 护盾吸收
        if (target.getAppendage(BUFF_MAGIC_SHIELD))
        {
            local shield = target.getAppendage(BUFF_MAGIC_SHIELD);
            local shieldValue = shield.getData("shieldValue") || 0;
            
            if (shieldValue > 0)
            {
                local absorbed = min(damageData.finalDamage, shieldValue);
                damageData.finalDamage -= absorbed;
                shield.setData("shieldValue", shieldValue - absorbed);
                
                // 显示护盾吸收
                target.showShieldAbsorb(absorbed);
                
                // 护盾耗尽时移除
                if (shieldValue - absorbed <= 0)
                {
                    target.removeAppendage(BUFF_MAGIC_SHIELD);
                }
            }
        }
    }
    
    // =====================================
    // 应用随机浮动
    // =====================================
    function applyRandomFloat(damageData)
    {
        if (!this.config.enableRandomFloat)
            return;
        
        local oldDamage = damageData.finalDamage;
        local range = this.config.randomFloatRange;
        
        // 生成随机倍率 (1 ± range)
        local randomFactor = 1.0 + (rand() % 2001 - 1000) / 1000.0 * range;
        damageData.finalDamage *= randomFactor;
        
        // 记录修正信息
        damageData.modifiers.append({
            type = "RandomFloat",
            oldValue = oldDamage,
            newValue = damageData.finalDamage,
            factor = randomFactor
        });
        
        if (this.config.debugMode)
        {
            damageData.debugInfo.append("随机浮动: " + oldDamage + " -> " + damageData.finalDamage);
        }
    }
    
    // =====================================
    // 应用最终修正
    // =====================================
    function applyFinalModifiers(damageData)
    {
        // 应用自定义修正器
        foreach (modifier in this.damageModifiers)
        {
            if (modifier.condition(damageData))
            {
                local oldDamage = damageData.finalDamage;
                damageData.finalDamage = modifier.apply(damageData.finalDamage, damageData);
                
                // 记录修正信息
                damageData.modifiers.append({
                    type = "CustomModifier",
                    name = modifier.name,
                    oldValue = oldDamage,
                    newValue = damageData.finalDamage
                });
            }
        }
        
        // 确保伤害为整数
        damageData.finalDamage = damageData.finalDamage.tointeger();
    }
    
    // =====================================
    // 添加自定义修正器
    // =====================================
    function addDamageModifier(name, condition, apply)
    {
        this.damageModifiers[name] <- {
            name = name,
            condition = condition,
            apply = apply
        };
    }
    
    // =====================================
    // 移除自定义修正器
    // =====================================
    function removeDamageModifier(name)
    {
        if (name in this.damageModifiers)
        {
            delete this.damageModifiers[name];
        }
    }
    
    // =====================================
    // 打印调试信息
    // =====================================
    function printDebugInfo(damageData)
    {
        print("=== 伤害计算调试信息 ===");
        print("攻击者: " + damageData.attacker.getName());
        print("目标: " + damageData.target.getName());
        print("基础伤害: " + damageData.baseDamage);
        print("最终伤害: " + damageData.finalDamage);
        print("是否暴击: " + (damageData.isCritical ? "是" : "否"));
        
        print("--- 修正过程 ---");
        foreach (info in damageData.debugInfo)
        {
            print(info);
        }
        
        print("--- 修正器详情 ---");
        foreach (modifier in damageData.modifiers)
        {
            print(modifier.type + ": " + modifier.oldValue + " -> " + modifier.newValue);
        }
        
        print("==================");
    }
    
    // =====================================
    // 燃烧效果
    // =====================================
    function applyBurnEffect(target, damagePerSecond, duration)
    {
        local burnAP = sq_AppendAppendage(target, target, DEBUFF_BURN, true, 
                                         "character/common/appendage/burn.nut", duration);
        if (burnAP)
        {
            burnAP.setData("damagePerSecond", damagePerSecond);
            burnAP.setData("tickInterval", 1000);  // 每秒一次
        }
    }
    
    // =====================================
    // 冰冻效果
    // =====================================
    function applyFreezeEffect(target, duration)
    {
        local freezeAP = sq_AppendAppendage(target, target, DEBUFF_FREEZE, true, 
                                           "character/common/appendage/freeze.nut", duration);
        if (freezeAP)
        {
            target.setState(STATE_FREEZE);
        }
    }
    
    // =====================================
    // 麻痹效果
    // =====================================
    function applyParalyzeEffect(target, duration)
    {
        local paralyzeAP = sq_AppendAppendage(target, target, DEBUFF_PARALYZE, true, 
                                             "character/common/appendage/paralyze.nut", duration);
        if (paralyzeAP)
        {
            target.addMoveSpeedRate(-0.5);  // 减速50%
        }
    }
    
    // =====================================
    // 诅咒效果
    // =====================================
    function applyCurseEffect(target, duration)
    {
        local curseAP = sq_AppendAppendage(target, target, DEBUFF_CURSE, true, 
                                          "character/common/appendage/curse.nut", duration);
        if (curseAP)
        {
            target.addPhysicalAttackRate(-0.3);  // 减少30%攻击力
            target.addMagicalAttackRate(-0.3);
        }
    }
}

// =====================================
// 全局伤害计算器实例
// =====================================
local g_DamageCalculator = DamageCalculator();

// =====================================
// 便捷函数 - 计算物理伤害
// =====================================
function calculatePhysicalDamage(attacker, target, baseDamage, options = {})
{
    return g_DamageCalculator.calculateDamage(attacker, target, baseDamage, 
                                             DAMAGE_TYPE_PHYSICAL, ELEMENT_NONE, options);
}

// =====================================
// 便捷函数 - 计算魔法伤害
// =====================================
function calculateMagicalDamage(attacker, target, baseDamage, elementType = ELEMENT_NONE, options = {})
{
    return g_DamageCalculator.calculateDamage(attacker, target, baseDamage, 
                                             DAMAGE_TYPE_MAGICAL, elementType, options);
}

// =====================================
// 便捷函数 - 计算真实伤害
// =====================================
function calculateTrueDamage(attacker, target, baseDamage, options = {})
{
    return g_DamageCalculator.calculateDamage(attacker, target, baseDamage, 
                                             DAMAGE_TYPE_TRUE, ELEMENT_NONE, options);
}

// =====================================
// 便捷函数 - 应用伤害到目标
// =====================================
function applyDamageToTarget(damageData)
{
    local target = damageData.target;
    local damage = damageData.finalDamage;
    
    // 应用伤害
    target.addHp(-damage);
    
    // 显示伤害数字
    local damageType = DAMAGE_TYPE_PHYSICAL;
    if (damageData.isCritical)
    {
        damageType = DAMAGE_TYPE_CRITICAL;
    }
    
    target.showDamage(damage, damageType);
    
    // 播放受击音效
    target.playSound("hit_sound.wav");
    
    // 添加受击特效
    createHitEffect(target, damageData);
    
    // 检查击杀
    if (target.getHp() <= 0)
    {
        handleKill(damageData.attacker, target);
    }
    
    return damageData;
}

// =====================================
// 创建受击特效
// =====================================
function createHitEffect(target, damageData)
{
    local effectName = "character/common/effect/hit.ani";
    
    // 根据伤害类型选择特效
    switch (damageData.damageType)
    {
        case DAMAGE_TYPE_PHYSICAL:
            effectName = "character/common/effect/physical_hit.ani";
            break;
        case DAMAGE_TYPE_MAGICAL:
            effectName = "character/common/effect/magical_hit.ani";
            break;
        case DAMAGE_TYPE_TRUE:
            effectName = "character/common/effect/true_hit.ani";
            break;
    }
    
    // 根据元素类型调整特效
    if (damageData.elementType != ELEMENT_NONE)
    {
        local elementNames = ["", "fire", "ice", "lightning", "dark"];
        effectName = "character/common/effect/" + elementNames[damageData.elementType] + "_hit.ani";
    }
    
    // 创建特效
    local hitEffect = sq_CreateDrawOnlyObject(target, effectName, LAYER_TOP, true);
    if (hitEffect)
    {
        hitEffect.setXPos(target.getXPos());
        hitEffect.setYPos(target.getYPos() + 50);
        hitEffect.setZPos(target.getZPos());
        hitEffect.setTimeEvent(0, 500, 1, false);
        
        // 暴击特效更大
        if (damageData.isCritical)
        {
            hitEffect.setScale(1.5, 1.5);
        }
    }
}

// =====================================
// 处理击杀
// =====================================
function handleKill(attacker, target)
{
    // 播放击杀音效
    attacker.playSound("kill_sound.wav");
    
    // 给攻击者加经验
    local exp = target.getLevel() * 10;
    attacker.addExp(exp);
    
    // 显示击杀特效
    local killEffect = sq_CreateDrawOnlyObject(target, "character/common/effect/kill.ani", 
                                              LAYER_TOP, true);
    if (killEffect)
    {
        killEffect.setXPos(target.getXPos());
        killEffect.setYPos(target.getYPos());
        killEffect.setZPos(target.getZPos());
        killEffect.setTimeEvent(0, 1000, 1, false);
    }
    
    // 屏幕震动
    sq_ShakeScreen(attacker, 200, 8, 8);
}
```

## 使用示例

### 基础用法

```nut
// 创建技能数据
local skillData = {
    damage_type = DAMAGE_TYPE_PHYSICAL,
    damage_rate = 250,  // 250%攻击力
    element = ELEMENT_FIRE,
    penetration = 20    // 20%穿透
};

// 计算伤害
local damage = calculateFinalDamage(attacker, target, skillData);

// 应用伤害
applyDamage(target, damage, attacker, skillData);
```

### 高级用法

```nut
// 复杂技能伤害计算
local skillData = {
    damage_type = DAMAGE_TYPE_MAGICAL,
    damage_rate = 300,
    element = ELEMENT_ICE,
    fixed_damage = 0,
    penetration = 15,
    special_effects = ["freeze_chance", "mana_burn"]
};

// 计算并应用带特效的伤害
local damage = calculateFinalDamage(attacker, target, skillData);
applyDamageWithEffects(target, damage, attacker, skillData);

// 调试伤害计算
debugDamageCalculation(attacker, target, skillData);
```

## 常见问题解答

**Q: 伤害计算结果不准确？**
A: 检查攻击力、防御力获取是否正确，确认技能倍率设置。

**Q: 暴击不生效？**
A: 检查暴击率计算和随机数生成逻辑。

**Q: 元素伤害异常？**
A: 确认元素属性设置和抗性计算公式。

**Q: 性能问题？**
A: 避免在伤害计算中进行复杂的状态检查，使用缓存机制。

## 相关文档

- [标签参考.md](../../标签参考.md) - NUT脚本函数详细说明
- [基础攻击技能.md](../入门级/基础攻击技能.md) - 攻击技能实现示例
- [问题解答.md](../../问题解答.md) - 常见问题解决方案