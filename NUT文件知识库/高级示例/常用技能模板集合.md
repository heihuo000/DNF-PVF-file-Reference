# 常用技能模板集合

## 目录

1. [基础攻击技能模板](#基础攻击技能模板)
2. [范围攻击技能模板](#范围攻击技能模板)
3. [BUFF技能模板](#buff技能模板)
4. [召唤技能模板](#召唤技能模板)
5. [位移技能模板](#位移技能模板)
6. [连击技能模板](#连击技能模板)
7. [蓄力技能模板](#蓄力技能模板)
8. [被动技能模板](#被动技能模板)
9. [组合技能模板](#组合技能模板)
10. [特殊效果技能模板](#特殊效果技能模板)

---

## 基础攻击技能模板

### 单体物理攻击技能

```squirrel
// 基础单体攻击技能模板
// 适用于：普通攻击、单体技能等

function checkExecutableSkill_BasicAttack(obj)
{
    // 基础检查
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 20;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "BasicAttack", 1000)) return false;
    
    // 检查目标
    local target = obj.sq_GetNearestEnemy(200);
    if (!target) return false;
    
    return true;
}

function onSetState_BasicAttack(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 20;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用时间
    recordSkillUse(obj, "BasicAttack");
    
    // 设置攻击动画
    obj.sq_SetCurrentAnimation(ANIMATION_ATTACK);
    
    // 存储技能数据
    obj.sq_SetStaticInt(0, 1);  // 技能阶段标记
    obj.sq_SetStaticFloat(0, 1.5);  // 伤害倍率
    
    // 设置攻击判定时机
    obj.sq_SetMyShake(obj, 150, 80);
    obj.sq_SetAttackInfo(obj, 0, 0, 100, 50, 10, 1.0, 0, 0, 0);
}

function onEndCurrentAni_BasicAttack(obj)
{
    if (!obj) return;
    
    local phase = obj.sq_GetStaticInt(0);
    
    if (phase == 1) {
        // 执行攻击判定
        executeBasicAttack(obj);
        
        // 切换到站立状态
        obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    }
}

function executeBasicAttack(obj)
{
    // 获取目标
    local target = obj.sq_GetNearestEnemy(200);
    if (!target) return;
    
    // 计算伤害
    local damageRate = obj.sq_GetStaticFloat(0);
    local damage = calculatePhysicalDamage(obj, target, damageRate);
    
    // 造成伤害
    target.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
    
    // 创建攻击效果
    createAttackEffect(target.sq_GetPos(), "basic_attack_hit");
    
    // 击退效果
    local knockback = sq_Vector3(obj.sq_GetDirection() * 50, 0, 0);
    target.sq_AddForce(knockback, 300);
    
    // 记录伤害日志
    AdvancedLog(LogLevel.INFO, "SKILL", 
               "Basic attack hit: " + damage + " damage to " + target.sq_GetObjectIndex());
}
```

### 魔法攻击技能模板

```squirrel
// 基础魔法攻击技能模板
// 适用于：火球术、冰箭等单体魔法攻击

function checkExecutableSkill_MagicMissile(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 50;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "MagicMissile", 3000)) return false;
    
    // 检查施法距离
    local target = obj.sq_GetNearestEnemy(400);
    if (!target) return false;
    
    return true;
}

function onSetState_MagicMissile(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 50;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "MagicMissile");
    
    // 设置施法动画
    obj.sq_SetCurrentAnimation(ANIMATION_CAST);
    
    // 存储目标信息
    local target = obj.sq_GetNearestEnemy(400);
    if (target) {
        obj.sq_SetStaticInt(0, target.sq_GetObjectIndex());
        obj.sq_SetStaticFloat(0, 2.0);  // 魔法伤害倍率
    }
    
    // 施法时间
    obj.sq_SetMyShake(obj, 200, 100);
}

function onEndCurrentAni_MagicMissile(obj)
{
    if (!obj) return;
    
    // 发射魔法弹
    launchMagicMissile(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function launchMagicMissile(obj)
{
    local targetIndex = obj.sq_GetStaticInt(0);
    local target = sq_GetObjectFromIndex(targetIndex);
    
    if (!target) return;
    
    // 创建魔法弹对象
    local missile = obj.sq_CreateProjectile(
        obj.sq_GetPos(),                    // 起始位置
        target.sq_GetPos(),                 // 目标位置
        300,                                // 飞行速度
        "magic_missile_projectile"          // 弹道对象类型
    );
    
    if (missile) {
        // 设置弹道属性
        missile.sq_SetStaticInt(0, obj.sq_GetObjectIndex());        // 施法者
        missile.sq_SetStaticInt(1, targetIndex);                    // 目标
        missile.sq_SetStaticFloat(0, obj.sq_GetStaticFloat(0));     // 伤害倍率
        
        // 设置弹道效果
        missile.sq_SetCurrentAnimation(ANIMATION_PROJECTILE);
        
        // 添加追踪效果
        missile.sq_SetMoveParent(target, true);
    }
}

// 魔法弹命中处理
function onHit_MagicMissile(missile, target)
{
    if (!missile || !target) return;
    
    local casterIndex = missile.sq_GetStaticInt(0);
    local caster = sq_GetObjectFromIndex(casterIndex);
    
    if (!caster) return;
    
    // 计算魔法伤害
    local damageRate = missile.sq_GetStaticFloat(0);
    local damage = calculateMagicalDamage(caster, target, damageRate);
    
    // 造成伤害
    target.sq_AddDamage(damage, caster, DAMAGE_TYPE_MAGICAL);
    
    // 创建命中效果
    createMagicHitEffect(target.sq_GetPos(), "magic_missile_explosion");
    
    // 销毁弹道
    missile.sq_Delete();
}
```

---

## 范围攻击技能模板

### 圆形范围攻击

```squirrel
// 圆形范围攻击技能模板
// 适用于：爆炸术、震地波等

function checkExecutableSkill_CircleAttack(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 80;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "CircleAttack", 5000)) return false;
    
    return true;
}

function onSetState_CircleAttack(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 80;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "CircleAttack");
    
    // 设置施法动画
    obj.sq_SetCurrentAnimation(ANIMATION_SKILL);
    
    // 设置技能参数
    obj.sq_SetStaticFloat(0, 200.0);    // 攻击半径
    obj.sq_SetStaticFloat(1, 1.8);      // 伤害倍率
    obj.sq_SetStaticInt(0, 0);          // 阶段标记
    
    // 施法延迟
    obj.sq_SetMyShake(obj, 300, 150);
}

function onEndCurrentAni_CircleAttack(obj)
{
    if (!obj) return;
    
    local phase = obj.sq_GetStaticInt(0);
    
    if (phase == 0) {
        // 执行范围攻击
        executeCircleAttack(obj);
        obj.sq_SetStaticInt(0, 1);
        
        // 切换到站立状态
        obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    }
}

function executeCircleAttack(obj)
{
    local centerPos = obj.sq_GetPos();
    local radius = obj.sq_GetStaticFloat(0);
    local damageRate = obj.sq_GetStaticFloat(1);
    
    // 创建范围攻击效果
    createAreaEffect(centerPos, radius, "circle_attack_effect");
    
    // 获取范围内的所有敌人
    local enemies = obj.sq_GetEnemiesInRange(centerPos, radius);
    
    foreach (enemy in enemies) {
        if (!enemy) continue;
        
        // 计算距离衰减
        local distance = getDistance(centerPos, enemy.sq_GetPos());
        local distanceRate = 1.0 - (distance / radius) * 0.3;  // 最多减少30%伤害
        
        // 计算最终伤害
        local finalDamageRate = damageRate * distanceRate;
        local damage = calculatePhysicalDamage(obj, enemy, finalDamageRate);
        
        // 造成伤害
        enemy.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
        
        // 击飞效果
        local direction = getDirection(centerPos, enemy.sq_GetPos());
        local knockback = sq_Vector3(direction.x * 100, direction.y * 100, 50);
        enemy.sq_AddForce(knockback, 500);
        
        // 创建个体命中效果
        createHitEffect(enemy.sq_GetPos(), "circle_hit_effect");
    }
    
    // 地面震动效果
    obj.sq_SetMyShake(obj, 500, 200);
}
```

### 扇形范围攻击

```squirrel
// 扇形范围攻击技能模板
// 适用于：剑气斩、火焰喷射等

function checkExecutableSkill_SectorAttack(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 60;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "SectorAttack", 4000)) return false;
    
    return true;
}

function onSetState_SectorAttack(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 60;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "SectorAttack");
    
    // 设置攻击动画
    obj.sq_SetCurrentAnimation(ANIMATION_ATTACK);
    
    // 设置扇形参数
    obj.sq_SetStaticFloat(0, 250.0);    // 攻击距离
    obj.sq_SetStaticFloat(1, 60.0);     // 扇形角度(度)
    obj.sq_SetStaticFloat(2, 2.2);      // 伤害倍率
    
    // 攻击延迟
    obj.sq_SetMyShake(obj, 200, 100);
}

function onEndCurrentAni_SectorAttack(obj)
{
    if (!obj) return;
    
    // 执行扇形攻击
    executeSectorAttack(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function executeSectorAttack(obj)
{
    local startPos = obj.sq_GetPos();
    local direction = obj.sq_GetDirection();
    local range = obj.sq_GetStaticFloat(0);
    local angle = obj.sq_GetStaticFloat(1);
    local damageRate = obj.sq_GetStaticFloat(2);
    
    // 创建扇形攻击效果
    createSectorEffect(startPos, direction, range, angle, "sector_attack_effect");
    
    // 获取扇形范围内的敌人
    local enemies = getSectorEnemies(obj, startPos, direction, range, angle);
    
    foreach (enemy in enemies) {
        if (!enemy) continue;
        
        // 计算距离和角度衰减
        local distance = getDistance(startPos, enemy.sq_GetPos());
        local enemyAngle = getAngleBetween(startPos, enemy.sq_GetPos(), direction);
        
        local distanceRate = 1.0 - (distance / range) * 0.2;
        local angleRate = 1.0 - (abs(enemyAngle) / (angle / 2.0)) * 0.1;
        
        // 计算最终伤害
        local finalDamageRate = damageRate * distanceRate * angleRate;
        local damage = calculatePhysicalDamage(obj, enemy, finalDamageRate);
        
        // 造成伤害
        enemy.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
        
        // 击退效果
        local knockDirection = getDirection(startPos, enemy.sq_GetPos());
        local knockback = sq_Vector3(knockDirection.x * 80, knockDirection.y * 80, 30);
        enemy.sq_AddForce(knockback, 400);
        
        // 创建命中效果
        createHitEffect(enemy.sq_GetPos(), "sector_hit_effect");
    }
}

// 获取扇形范围内的敌人
function getSectorEnemies(obj, centerPos, direction, range, angle)
{
    local enemies = [];
    local allEnemies = obj.sq_GetEnemiesInRange(centerPos, range);
    
    foreach (enemy in allEnemies) {
        if (!enemy) continue;
        
        // 计算敌人相对于中心点的角度
        local enemyAngle = getAngleBetween(centerPos, enemy.sq_GetPos(), direction);
        
        // 检查是否在扇形角度范围内
        if (abs(enemyAngle) <= angle / 2.0) {
            enemies.append(enemy);
        }
    }
    
    return enemies;
}
```

---

## BUFF技能模板

### 自身BUFF技能

```squirrel
// 自身BUFF技能模板
// 适用于：力量增强、速度提升等

function checkExecutableSkill_SelfBuff(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 40;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "SelfBuff", 30000)) return false;
    
    // 检查是否已有相同BUFF
    if (obj.sq_IsBuffExist("BUFF_SELF_ENHANCE")) return false;
    
    return true;
}

function onSetState_SelfBuff(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 40;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "SelfBuff");
    
    // 设置施法动画
    obj.sq_SetCurrentAnimation(ANIMATION_BUFF);
    
    // 设置BUFF参数
    obj.sq_SetStaticFloat(0, 1.5);      // 攻击力增幅倍率
    obj.sq_SetStaticFloat(1, 1.3);      // 移动速度增幅倍率
    obj.sq_SetStaticInt(0, 30000);      // BUFF持续时间(毫秒)
    
    // 施法时间
    obj.sq_SetMyShake(obj, 150, 75);
}

function onEndCurrentAni_SelfBuff(obj)
{
    if (!obj) return;
    
    // 应用BUFF效果
    applySelfBuff(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function applySelfBuff(obj)
{
    local attackBonus = obj.sq_GetStaticFloat(0);
    local speedBonus = obj.sq_GetStaticFloat(1);
    local duration = obj.sq_GetStaticInt(0);
    
    // 创建BUFF对象
    local buff = obj.sq_AddBuff("BUFF_SELF_ENHANCE", duration);
    
    if (buff) {
        // 设置BUFF属性
        buff.sq_SetStaticFloat(0, attackBonus);
        buff.sq_SetStaticFloat(1, speedBonus);
        
        // 应用属性修改
        local currentAttack = obj.sq_GetPhysicalAttack();
        local currentSpeed = obj.sq_GetMoveSpeed();
        
        obj.sq_SetPhysicalAttack(currentAttack * attackBonus);
        obj.sq_SetMoveSpeed(currentSpeed * speedBonus);
        
        // 创建BUFF效果
        createBuffEffect(obj, "self_enhance_effect", duration);
        
        // 播放BUFF音效
        obj.sq_PlaySound("buff_apply_sound");
        
        AdvancedLog(LogLevel.INFO, "BUFF", 
                   "Self buff applied: Attack x" + attackBonus + ", Speed x" + speedBonus);
    }
}

// BUFF结束时的处理
function onBuffEnd_SelfBuff(obj, buff)
{
    if (!obj || !buff) return;
    
    local attackBonus = buff.sq_GetStaticFloat(0);
    local speedBonus = buff.sq_GetStaticFloat(1);
    
    // 恢复原始属性
    local currentAttack = obj.sq_GetPhysicalAttack();
    local currentSpeed = obj.sq_GetMoveSpeed();
    
    obj.sq_SetPhysicalAttack(currentAttack / attackBonus);
    obj.sq_SetMoveSpeed(currentSpeed / speedBonus);
    
    // 移除视觉效果
    removeBuffEffect(obj, "self_enhance_effect");
    
    // 播放BUFF结束音效
    obj.sq_PlaySound("buff_end_sound");
    
    AdvancedLog(LogLevel.INFO, "BUFF", "Self buff expired");
}
```

### 团队BUFF技能

```squirrel
// 团队BUFF技能模板
// 适用于：团队增益、光环技能等

function checkExecutableSkill_TeamBuff(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 100;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "TeamBuff", 60000)) return false;
    
    return true;
}

function onSetState_TeamBuff(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 100;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "TeamBuff");
    
    // 设置施法动画
    obj.sq_SetCurrentAnimation(ANIMATION_BUFF);
    
    // 设置团队BUFF参数
    obj.sq_SetStaticFloat(0, 300.0);    // 影响范围
    obj.sq_SetStaticFloat(1, 1.4);      // 攻击力增幅
    obj.sq_SetStaticFloat(2, 1.2);      // 防御力增幅
    obj.sq_SetStaticInt(0, 45000);      // 持续时间
    
    // 施法时间
    obj.sq_SetMyShake(obj, 250, 125);
}

function onEndCurrentAni_TeamBuff(obj)
{
    if (!obj) return;
    
    // 应用团队BUFF
    applyTeamBuff(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function applyTeamBuff(obj)
{
    local range = obj.sq_GetStaticFloat(0);
    local attackBonus = obj.sq_GetStaticFloat(1);
    local defenseBonus = obj.sq_GetStaticFloat(2);
    local duration = obj.sq_GetStaticInt(0);
    
    local centerPos = obj.sq_GetPos();
    
    // 获取范围内的所有友军(包括自己)
    local allies = obj.sq_GetAlliesInRange(centerPos, range);
    allies.append(obj);  // 包括施法者自己
    
    // 创建范围效果
    createAreaEffect(centerPos, range, "team_buff_area_effect");
    
    foreach (ally in allies) {
        if (!ally) continue;
        
        // 检查是否已有相同BUFF
        if (ally.sq_IsBuffExist("BUFF_TEAM_ENHANCE")) {
            // 刷新现有BUFF
            ally.sq_RefreshBuff("BUFF_TEAM_ENHANCE", duration);
            continue;
        }
        
        // 创建新BUFF
        local buff = ally.sq_AddBuff("BUFF_TEAM_ENHANCE", duration);
        
        if (buff) {
            // 设置BUFF属性
            buff.sq_SetStaticFloat(0, attackBonus);
            buff.sq_SetStaticFloat(1, defenseBonus);
            
            // 应用属性修改
            local currentAttack = ally.sq_GetPhysicalAttack();
            local currentDefense = ally.sq_GetPhysicalDefense();
            
            ally.sq_SetPhysicalAttack(currentAttack * attackBonus);
            ally.sq_SetPhysicalDefense(currentDefense * defenseBonus);
            
            // 创建个体BUFF效果
            createBuffEffect(ally, "team_enhance_effect", duration);
            
            // 播放BUFF音效
            ally.sq_PlaySound("team_buff_apply_sound");
        }
    }
    
    AdvancedLog(LogLevel.INFO, "BUFF", 
               "Team buff applied to " + allies.len() + " allies");
}

// 团队BUFF结束处理
function onBuffEnd_TeamBuff(obj, buff)
{
    if (!obj || !buff) return;
    
    local attackBonus = buff.sq_GetStaticFloat(0);
    local defenseBonus = buff.sq_GetStaticFloat(1);
    
    // 恢复原始属性
    local currentAttack = obj.sq_GetPhysicalAttack();
    local currentDefense = obj.sq_GetPhysicalDefense();
    
    obj.sq_SetPhysicalAttack(currentAttack / attackBonus);
    obj.sq_SetPhysicalDefense(currentDefense / defenseBonus);
    
    // 移除视觉效果
    removeBuffEffect(obj, "team_enhance_effect");
    
    // 播放BUFF结束音效
    obj.sq_PlaySound("team_buff_end_sound");
}
```

---

## 召唤技能模板

### 召唤生物技能

```squirrel
// 召唤生物技能模板
// 适用于：召唤宠物、召唤守卫等

function checkExecutableSkill_SummonCreature(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 120;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "SummonCreature", 20000)) return false;
    
    // 检查召唤数量限制
    local currentSummons = obj.sq_GetSummonCount("SummonedCreature");
    if (currentSummons >= 3) return false;  // 最多3个召唤物
    
    return true;
}

function onSetState_SummonCreature(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 120;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "SummonCreature");
    
    // 设置召唤动画
    obj.sq_SetCurrentAnimation(ANIMATION_SUMMON);
    
    // 设置召唤参数
    obj.sq_SetStaticFloat(0, 150.0);    // 召唤距离
    obj.sq_SetStaticInt(0, 30000);      // 召唤物存在时间
    obj.sq_SetStaticFloat(1, 0.8);      // 召唤物属性倍率
    
    // 召唤施法时间
    obj.sq_SetMyShake(obj, 400, 200);
}

function onEndCurrentAni_SummonCreature(obj)
{
    if (!obj) return;
    
    // 执行召唤
    executeSummon(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function executeSummon(obj)
{
    local summonDistance = obj.sq_GetStaticFloat(0);
    local duration = obj.sq_GetStaticInt(0);
    local attributeRate = obj.sq_GetStaticFloat(1);
    
    // 计算召唤位置
    local casterPos = obj.sq_GetPos();
    local direction = obj.sq_GetDirection();
    local summonPos = sq_Vector3(
        casterPos.x + direction * summonDistance,
        casterPos.y,
        casterPos.z
    );
    
    // 创建召唤圈效果
    createSummonCircle(summonPos, "summon_circle_effect");
    
    // 创建召唤生物
    local summon = obj.sq_CreateSummon(
        "SummonedCreature",     // 召唤物类型
        summonPos,              // 召唤位置
        duration                // 存在时间
    );
    
    if (summon) {
        // 设置召唤物属性
        setupSummonAttributes(summon, obj, attributeRate);
        
        // 设置召唤物AI
        summon.sq_SetAI("SummonCreatureAI");
        
        // 设置主人
        summon.sq_SetMaster(obj);
        
        // 创建召唤完成效果
        createSummonEffect(summonPos, "summon_complete_effect");
        
        // 播放召唤音效
        obj.sq_PlaySound("summon_creature_sound");
        
        AdvancedLog(LogLevel.INFO, "SUMMON", 
                   "Creature summoned at (" + summonPos.x + ", " + summonPos.y + ")");
    }
}

function setupSummonAttributes(summon, master, attributeRate)
{
    if (!summon || !master) return;
    
    // 基于主人属性设置召唤物属性
    local masterAttack = master.sq_GetPhysicalAttack();
    local masterDefense = master.sq_GetPhysicalDefense();
    local masterHP = master.sq_GetMaxHP();
    
    summon.sq_SetPhysicalAttack(masterAttack * attributeRate);
    summon.sq_SetPhysicalDefense(masterDefense * attributeRate);
    summon.sq_SetMaxHP(masterHP * attributeRate * 0.6);  // HP稍低一些
    summon.sq_SetHP(summon.sq_GetMaxHP());
    
    // 设置召唤物特殊能力
    summon.sq_SetStaticFloat(0, attributeRate);  // 保存属性倍率
    summon.sq_SetStaticInt(0, master.sq_GetObjectIndex());  // 保存主人索引
    
    // 设置召唤物行为模式
    summon.sq_SetBehaviorMode(BEHAVIOR_FOLLOW_MASTER);
}

// 召唤物AI行为
function updateSummonAI(summon)
{
    if (!summon) return;
    
    local masterIndex = summon.sq_GetStaticInt(0);
    local master = sq_GetObjectFromIndex(masterIndex);
    
    if (!master) {
        // 主人不存在，销毁召唤物
        summon.sq_Delete();
        return;
    }
    
    local masterPos = master.sq_GetPos();
    local summonPos = summon.sq_GetPos();
    local distance = getDistance(masterPos, summonPos);
    
    // 寻找附近的敌人
    local enemy = summon.sq_GetNearestEnemy(200);
    
    if (enemy) {
        // 有敌人时攻击
        summonAttackEnemy(summon, enemy);
    } else if (distance > 300) {
        // 距离主人太远时跟随
        summonFollowMaster(summon, master);
    } else {
        // 待机状态
        summon.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    }
}

function summonAttackEnemy(summon, enemy)
{
    if (!summon || !enemy) return;
    
    // 面向敌人
    local direction = getDirection(summon.sq_GetPos(), enemy.sq_GetPos());
    summon.sq_SetDirection(direction.x > 0 ? 1 : -1);
    
    // 执行攻击
    summon.sq_AddSetStatePacket(STATE_ATTACK, STATE_PRIORITY_USER, false);
}

function summonFollowMaster(summon, master)
{
    if (!summon || !master) return;
    
    local masterPos = master.sq_GetPos();
    local targetPos = sq_Vector3(
        masterPos.x + (master.sq_GetDirection() * -100),  // 跟在主人后面
        masterPos.y,
        masterPos.z
    );
    
    // 移动到目标位置
    summon.sq_MoveToPos(targetPos, 150);  // 移动速度
}
```

### 召唤陷阱技能

```squirrel
// 召唤陷阱技能模板
// 适用于：地雷、冰冻陷阱等

function checkExecutableSkill_SummonTrap(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 60;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "SummonTrap", 8000)) return false;
    
    // 检查陷阱数量限制
    local currentTraps = obj.sq_GetSummonCount("SummonedTrap");
    if (currentTraps >= 5) return false;  // 最多5个陷阱
    
    return true;
}

function onSetState_SummonTrap(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 60;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "SummonTrap");
    
    // 设置放置动画
    obj.sq_SetCurrentAnimation(ANIMATION_SKILL);
    
    // 设置陷阱参数
    obj.sq_SetStaticFloat(0, 100.0);    // 放置距离
    obj.sq_SetStaticFloat(1, 80.0);     // 触发范围
    obj.sq_SetStaticFloat(2, 2.5);      // 爆炸伤害倍率
    obj.sq_SetStaticInt(0, 60000);      // 陷阱存在时间
    
    // 放置时间
    obj.sq_SetMyShake(obj, 200, 100);
}

function onEndCurrentAni_SummonTrap(obj)
{
    if (!obj) return;
    
    // 放置陷阱
    placeTrap(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function placeTrap(obj)
{
    local placeDistance = obj.sq_GetStaticFloat(0);
    local triggerRange = obj.sq_GetStaticFloat(1);
    local damageRate = obj.sq_GetStaticFloat(2);
    local duration = obj.sq_GetStaticInt(0);
    
    // 计算放置位置
    local casterPos = obj.sq_GetPos();
    local direction = obj.sq_GetDirection();
    local trapPos = sq_Vector3(
        casterPos.x + direction * placeDistance,
        casterPos.y,
        casterPos.z
    );
    
    // 创建陷阱对象
    local trap = obj.sq_CreateSummon(
        "SummonedTrap",         // 陷阱类型
        trapPos,                // 放置位置
        duration                // 存在时间
    );
    
    if (trap) {
        // 设置陷阱属性
        trap.sq_SetStaticFloat(0, triggerRange);    // 触发范围
        trap.sq_SetStaticFloat(1, damageRate);      // 伤害倍率
        trap.sq_SetStaticInt(0, obj.sq_GetObjectIndex());  // 设置者索引
        trap.sq_SetStaticInt(1, 0);                 // 状态标记(0=待机, 1=触发)
        
        // 设置陷阱为隐形状态
        trap.sq_SetVisible(false);
        
        // 创建放置效果
        createTrapPlaceEffect(trapPos, "trap_place_effect");
        
        // 播放放置音效
        obj.sq_PlaySound("trap_place_sound");
        
        AdvancedLog(LogLevel.INFO, "TRAP", 
                   "Trap placed at (" + trapPos.x + ", " + trapPos.y + ")");
    }
}

// 陷阱触发检测
function updateTrapTrigger(trap)
{
    if (!trap) return;
    
    local state = trap.sq_GetStaticInt(1);
    if (state != 0) return;  // 已触发或已爆炸
    
    local triggerRange = trap.sq_GetStaticFloat(0);
    local trapPos = trap.sq_GetPos();
    
    // 检测范围内的敌人
    local enemies = trap.sq_GetEnemiesInRange(trapPos, triggerRange);
    
    if (enemies.len() > 0) {
        // 触发陷阱
        triggerTrap(trap, enemies);
    }
}

function triggerTrap(trap, enemies)
{
    if (!trap) return;
    
    // 标记为已触发
    trap.sq_SetStaticInt(1, 1);
    
    local damageRate = trap.sq_GetStaticFloat(1);
    local setterIndex = trap.sq_GetStaticInt(0);
    local setter = sq_GetObjectFromIndex(setterIndex);
    local trapPos = trap.sq_GetPos();
    
    // 显示陷阱
    trap.sq_SetVisible(true);
    
    // 创建爆炸效果
    createExplosionEffect(trapPos, "trap_explosion_effect");
    
    // 对所有敌人造成伤害
    foreach (enemy in enemies) {
        if (!enemy || !setter) continue;
        
        // 计算伤害
        local damage = calculatePhysicalDamage(setter, enemy, damageRate);
        
        // 造成伤害
        enemy.sq_AddDamage(damage, setter, DAMAGE_TYPE_PHYSICAL);
        
        // 击飞效果
        local direction = getDirection(trapPos, enemy.sq_GetPos());
        local knockback = sq_Vector3(direction.x * 120, direction.y * 120, 80);
        enemy.sq_AddForce(knockback, 600);
        
        // 创建命中效果
        createHitEffect(enemy.sq_GetPos(), "trap_hit_effect");
    }
    
    // 播放爆炸音效
    trap.sq_PlaySound("trap_explosion_sound");
    
    // 延迟销毁陷阱
    trap.sq_SetTimer(500, function() {
        trap.sq_Delete();
    });
    
    AdvancedLog(LogLevel.INFO, "TRAP", 
               "Trap triggered, hit " + enemies.len() + " enemies");
}
```

---

## 位移技能模板

### 瞬移技能

```squirrel
// 瞬移技能模板
// 适用于：闪现、传送等

function checkExecutableSkill_Teleport(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 80;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "Teleport", 10000)) return false;
    
    return true;
}

function onSetState_Teleport(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 80;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "Teleport");
    
    // 设置瞬移动画
    obj.sq_SetCurrentAnimation(ANIMATION_TELEPORT);
    
    // 设置瞬移参数
    obj.sq_SetStaticFloat(0, 300.0);    // 瞬移距离
    obj.sq_SetStaticInt(0, 0);          // 阶段标记
    
    // 瞬移前效果
    createTeleportStartEffect(obj.sq_GetPos(), "teleport_start_effect");
    
    // 短暂延迟
    obj.sq_SetMyShake(obj, 100, 50);
}

function onEndCurrentAni_Teleport(obj)
{
    if (!obj) return;
    
    local phase = obj.sq_GetStaticInt(0);
    
    if (phase == 0) {
        // 执行瞬移
        executeTeleport(obj);
        obj.sq_SetStaticInt(0, 1);
        
        // 设置瞬移后动画
        obj.sq_SetCurrentAnimation(ANIMATION_TELEPORT_END);
    } else {
        // 瞬移完成，返回站立状态
        obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    }
}

function executeTeleport(obj)
{
    local teleportDistance = obj.sq_GetStaticFloat(0);
    local currentPos = obj.sq_GetPos();
    local direction = obj.sq_GetDirection();
    
    // 计算目标位置
    local targetPos = sq_Vector3(
        currentPos.x + direction * teleportDistance,
        currentPos.y,
        currentPos.z
    );
    
    // 检查目标位置是否有效
    if (!isValidPosition(targetPos)) {
        // 寻找最近的有效位置
        targetPos = findNearestValidPosition(targetPos, 100);
    }
    
    // 创建瞬移消失效果
    createTeleportDisappearEffect(currentPos, "teleport_disappear_effect");
    
    // 执行瞬移
    obj.sq_SetPos(targetPos);
    
    // 创建瞬移出现效果
    createTeleportAppearEffect(targetPos, "teleport_appear_effect");
    
    // 播放瞬移音效
    obj.sq_PlaySound("teleport_sound");
    
    // 短暂无敌时间
    obj.sq_AddBuff("BUFF_TELEPORT_INVINCIBLE", 500);
    
    AdvancedLog(LogLevel.INFO, "TELEPORT", 
               "Teleported from (" + currentPos.x + ", " + currentPos.y + 
               ") to (" + targetPos.x + ", " + targetPos.y + ")");
}

// 检查位置是否有效
function isValidPosition(pos)
{
    // 检查是否在地图边界内
    if (pos.x < MAP_MIN_X || pos.x > MAP_MAX_X) return false;
    if (pos.y < MAP_MIN_Y || pos.y > MAP_MAX_Y) return false;
    
    // 检查是否有障碍物
    if (hasObstacle(pos)) return false;
    
    return true;
}

// 寻找最近的有效位置
function findNearestValidPosition(targetPos, searchRadius)
{
    for (local radius = 10; radius <= searchRadius; radius += 10) {
        for (local angle = 0; angle < 360; angle += 30) {
            local testPos = sq_Vector3(
                targetPos.x + radius * cos(angle * PI / 180),
                targetPos.y + radius * sin(angle * PI / 180),
                targetPos.z
            );
            
            if (isValidPosition(testPos)) {
                return testPos;
            }
        }
    }
    
    // 如果找不到有效位置，返回原位置
    return targetPos;
}
```

### 冲刺技能

```squirrel
// 冲刺技能模板
// 适用于：突进、冲锋等

function checkExecutableSkill_Dash(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 30;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "Dash", 5000)) return false;
    
    return true;
}

function onSetState_Dash(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 30;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "Dash");
    
    // 设置冲刺动画
    obj.sq_SetCurrentAnimation(ANIMATION_DASH);
    
    // 设置冲刺参数
    obj.sq_SetStaticFloat(0, 250.0);    // 冲刺距离
    obj.sq_SetStaticFloat(1, 500.0);    // 冲刺速度
    obj.sq_SetStaticFloat(2, 1.5);      // 冲刺伤害倍率
    obj.sq_SetStaticInt(0, 0);          // 当前冲刺距离
    obj.sq_SetStaticInt(1, 0);          // 命中敌人数量
    
    // 创建冲刺开始效果
    createDashStartEffect(obj, "dash_start_effect");
    
    // 设置冲刺状态
    obj.sq_SetMoveSpeed(obj.sq_GetStaticFloat(1));
    
    // 开始冲刺
    startDashMovement(obj);
}

function startDashMovement(obj)
{
    local dashDistance = obj.sq_GetStaticFloat(0);
    local dashSpeed = obj.sq_GetStaticFloat(1);
    local direction = obj.sq_GetDirection();
    
    local currentPos = obj.sq_GetPos();
    local targetPos = sq_Vector3(
        currentPos.x + direction * dashDistance,
        currentPos.y,
        currentPos.z
    );
    
    // 开始移动
    obj.sq_MoveToPos(targetPos, dashSpeed);
    
    // 设置冲刺轨迹效果
    createDashTrailEffect(obj, "dash_trail_effect");
}

function onUpdate_Dash(obj)
{
    if (!obj) return;
    
    // 检查冲刺过程中的碰撞
    checkDashCollision(obj);
    
    // 检查是否到达目标位置
    if (!obj.sq_IsMoving()) {
        // 冲刺结束
        endDash(obj);
    }
}

function checkDashCollision(obj)
{
    local damageRate = obj.sq_GetStaticFloat(2);
    local hitCount = obj.sq_GetStaticInt(1);
    
    // 获取冲刺路径上的敌人
    local enemies = obj.sq_GetEnemiesInRange(obj.sq_GetPos(), 80);
    
    foreach (enemy in enemies) {
        if (!enemy) continue;
        
        // 检查是否已经命中过这个敌人
        if (hasHitEnemy(obj, enemy)) continue;
        
        // 记录命中
        markEnemyHit(obj, enemy);
        hitCount++;
        obj.sq_SetStaticInt(1, hitCount);
        
        // 计算伤害
        local damage = calculatePhysicalDamage(obj, enemy, damageRate);
        
        // 造成伤害
        enemy.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
        
        // 击飞效果
        local direction = obj.sq_GetDirection();
        local knockback = sq_Vector3(direction * 100, 0, 50);
        enemy.sq_AddForce(knockback, 400);
        
        // 创建命中效果
        createHitEffect(enemy.sq_GetPos(), "dash_hit_effect");
        
        // 播放命中音效
        obj.sq_PlaySound("dash_hit_sound");
        
        AdvancedLog(LogLevel.INFO, "DASH", "Dash hit enemy: " + damage + " damage");
    }
}

function endDash(obj)
{
    if (!obj) return;
    
    local hitCount = obj.sq_GetStaticInt(1);
    
    // 恢复正常移动速度
    obj.sq_SetMoveSpeed(obj.sq_GetDefaultMoveSpeed());
    
    // 创建冲刺结束效果
    createDashEndEffect(obj.sq_GetPos(), "dash_end_effect");
    
    // 如果命中了敌人，可以获得额外效果
    if (hitCount > 0) {
        // 恢复少量MP
        local mpRecover = hitCount * 5;
        obj.sq_AddMp(mpRecover);
        
        // 减少冷却时间
        reduceSkillCooldown(obj, "Dash", hitCount * 500);
    }
    
    // 清除命中记录
    clearHitEnemyList(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    
    AdvancedLog(LogLevel.INFO, "DASH", "Dash completed, hit " + hitCount + " enemies");
}

// 命中敌人记录系统
local g_dashHitRecords = {};

function markEnemyHit(obj, enemy)
{
    local objIndex = obj.sq_GetObjectIndex();
    local enemyIndex = enemy.sq_GetObjectIndex();
    
    if (!(objIndex in g_dashHitRecords)) {
        g_dashHitRecords[objIndex] <- [];
    }
    
    g_dashHitRecords[objIndex].append(enemyIndex);
}

function hasHitEnemy(obj, enemy)
{
    local objIndex = obj.sq_GetObjectIndex();
    local enemyIndex = enemy.sq_GetObjectIndex();
    
    if (!(objIndex in g_dashHitRecords)) return false;
    
    return g_dashHitRecords[objIndex].find(enemyIndex) != null;
}

function clearHitEnemyList(obj)
{
    local objIndex = obj.sq_GetObjectIndex();
    if (objIndex in g_dashHitRecords) {
        delete g_dashHitRecords[objIndex];
    }
}
```

---

## 连击技能模板

### 三段连击技能

```squirrel
// 三段连击技能模板
// 适用于：连续攻击、组合技等

function checkExecutableSkill_TripleCombo(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 40;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "TripleCombo", 6000)) return false;
    
    // 检查目标
    local target = obj.sq_GetNearestEnemy(150);
    if (!target) return false;
    
    return true;
}

function onSetState_TripleCombo(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 40;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "TripleCombo");
    
    // 设置连击参数
    obj.sq_SetStaticInt(0, 1);          // 当前连击段数
    obj.sq_SetStaticFloat(0, 1.2);      // 第一段伤害倍率
    obj.sq_SetStaticFloat(1, 1.5);      // 第二段伤害倍率
    obj.sq_SetStaticFloat(2, 2.0);      // 第三段伤害倍率
    
    // 开始第一段攻击
    startComboPhase(obj, 1);
}

function startComboPhase(obj, phase)
{
    if (!obj) return;
    
    obj.sq_SetStaticInt(0, phase);
    
    switch (phase) {
        case 1:
            // 第一段：快速刺击
            obj.sq_SetCurrentAnimation(ANIMATION_COMBO_1);
            obj.sq_SetMyShake(obj, 150, 75);
            createComboEffect(obj, "combo_phase1_effect");
            break;
            
        case 2:
            // 第二段：横扫攻击
            obj.sq_SetCurrentAnimation(ANIMATION_COMBO_2);
            obj.sq_SetMyShake(obj, 200, 100);
            createComboEffect(obj, "combo_phase2_effect");
            break;
            
        case 3:
            // 第三段：重击终结
            obj.sq_SetCurrentAnimation(ANIMATION_COMBO_3);
            obj.sq_SetMyShake(obj, 300, 150);
            createComboEffect(obj, "combo_phase3_effect");
            break;
    }
    
    AdvancedLog(LogLevel.INFO, "COMBO", "Starting combo phase " + phase);
}

function onEndCurrentAni_TripleCombo(obj)
{
    if (!obj) return;
    
    local currentPhase = obj.sq_GetStaticInt(0);
    
    // 执行当前段的攻击判定
    executeComboAttack(obj, currentPhase);
    
    if (currentPhase < 3) {
        // 继续下一段
        startComboPhase(obj, currentPhase + 1);
    } else {
        // 连击完成
        finishCombo(obj);
    }
}

function executeComboAttack(obj, phase)
{
    if (!obj) return;
    
    local damageRate = obj.sq_GetStaticFloat(phase - 1);
    local target = obj.sq_GetNearestEnemy(150);
    
    if (!target) return;
    
    // 根据连击段数调整攻击范围和效果
    local attackRange = 150;
    local knockbackForce = 50;
    
    switch (phase) {
        case 1:
            // 第一段：单体精确攻击
            attackRange = 120;
            knockbackForce = 30;
            break;
            
        case 2:
            // 第二段：小范围横扫
            attackRange = 180;
            knockbackForce = 60;
            break;
            
        case 3:
            // 第三段：大范围重击
            attackRange = 220;
            knockbackForce = 120;
            break;
    }
    
    // 获取攻击范围内的敌人
    local enemies = obj.sq_GetEnemiesInRange(obj.sq_GetPos(), attackRange);
    
    foreach (enemy in enemies) {
        if (!enemy) continue;
        
        // 计算伤害
        local damage = calculatePhysicalDamage(obj, enemy, damageRate);
        
        // 第三段有暴击效果
        if (phase == 3 && random(100) < 30) {  // 30%暴击率
            damage *= 1.5;
            createCriticalEffect(enemy.sq_GetPos(), "critical_hit_effect");
        }
        
        // 造成伤害
        enemy.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
        
        // 击退效果
        local direction = getDirection(obj.sq_GetPos(), enemy.sq_GetPos());
        local knockback = sq_Vector3(
            direction.x * knockbackForce,
            direction.y * knockbackForce,
            phase == 3 ? 80 : 30  // 第三段有击飞效果
        );
        enemy.sq_AddForce(knockback, 300 + phase * 100);
        
        // 创建命中效果
        createComboHitEffect(enemy.sq_GetPos(), "combo_hit_phase" + phase + "_effect");
        
        // 播放命中音效
        obj.sq_PlaySound("combo_hit_phase" + phase + "_sound");
    }
    
    AdvancedLog(LogLevel.INFO, "COMBO", 
               "Combo phase " + phase + " hit " + enemies.len() + " enemies");
}

function finishCombo(obj)
{
    if (!obj) return;
    
    // 创建连击完成效果
    createComboFinishEffect(obj.sq_GetPos(), "combo_finish_effect");
    
    // 播放连击完成音效
    obj.sq_PlaySound("combo_finish_sound");
    
    // 连击完成奖励
    local mpRecover = 20;
    obj.sq_AddMp(mpRecover);
    
    // 短暂的攻击力提升
    obj.sq_AddBuff("BUFF_COMBO_BOOST", 5000);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    
    AdvancedLog(LogLevel.INFO, "COMBO", "Triple combo completed");
}
```

---

## 蓄力技能模板

### 可变蓄力技能

```squirrel
// 可变蓄力技能模板
// 适用于：蓄力攻击、充能技能等

function checkExecutableSkill_ChargeAttack(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗(基础消耗)
    local baseMpCost = 30;
    if (obj.sq_GetMp() < baseMpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "ChargeAttack", 8000)) return false;
    
    return true;
}

function onSetState_ChargeAttack(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 基础MP消耗
    local baseMpCost = 30;
    obj.sq_AddMp(-baseMpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "ChargeAttack");
    
    // 设置蓄力动画
    obj.sq_SetCurrentAnimation(ANIMATION_CHARGE);
    
    // 初始化蓄力参数
    obj.sq_SetStaticFloat(0, 0.0);      // 当前蓄力时间
    obj.sq_SetStaticFloat(1, 3000.0);   // 最大蓄力时间(毫秒)
    obj.sq_SetStaticFloat(2, 1.0);      // 基础伤害倍率
    obj.sq_SetStaticFloat(3, 3.0);      // 最大伤害倍率
    obj.sq_SetStaticInt(0, 0);          // 蓄力阶段(0=蓄力中, 1=释放)
    
    // 开始蓄力
    startCharging(obj);
}

function startCharging(obj)
{
    if (!obj) return;
    
    // 创建蓄力开始效果
    createChargeStartEffect(obj, "charge_start_effect");
    
    // 播放蓄力音效
    obj.sq_PlaySound("charge_start_sound");
    
    // 设置蓄力更新定时器
    obj.sq_SetTimer(100, function() {
        updateCharging(obj);
    });
}

function updateCharging(obj)
{
    if (!obj) return;
    
    local chargePhase = obj.sq_GetStaticInt(0);
    if (chargePhase != 0) return;  // 不在蓄力阶段
    
    local currentChargeTime = obj.sq_GetStaticFloat(0);
    local maxChargeTime = obj.sq_GetStaticFloat(1);
    
    // 增加蓄力时间
    currentChargeTime += 100;
    obj.sq_SetStaticFloat(0, currentChargeTime);
    
    // 计算蓄力进度
    local chargeProgress = min(currentChargeTime / maxChargeTime, 1.0);
    
    // 更新蓄力效果
    updateChargeEffect(obj, chargeProgress);
    
    // 检查是否达到最大蓄力
    if (chargeProgress >= 1.0) {
        // 达到最大蓄力，自动释放
        releaseChargeAttack(obj);
    } else if (!obj.sq_IsKeyPressed(KEY_SKILL)) {
        // 玩家松开技能键，释放攻击
        releaseChargeAttack(obj);
    } else {
        // 继续蓄力
        obj.sq_SetTimer(100, function() {
            updateCharging(obj);
        });
    }
}

function updateChargeEffect(obj, progress)
{
    if (!obj) return;
    
    // 根据蓄力进度更新视觉效果
    local effectIntensity = progress;
    
    if (progress < 0.33) {
        // 初级蓄力效果
        createChargeEffect(obj, "charge_level1_effect", effectIntensity);
    } else if (progress < 0.66) {
        // 中级蓄力效果
        createChargeEffect(obj, "charge_level2_effect", effectIntensity);
    } else {
        // 高级蓄力效果
        createChargeEffect(obj, "charge_level3_effect", effectIntensity);
        
        // 最大蓄力时的特殊效果
        if (progress >= 1.0) {
            createMaxChargeEffect(obj, "max_charge_effect");
        }
    }
    
    // 蓄力音效变化
    local soundPitch = 1.0 + progress * 0.5;
    obj.sq_SetSoundPitch("charge_loop_sound", soundPitch);
}

function releaseChargeAttack(obj)
{
    if (!obj) return;
    
    // 标记为释放阶段
    obj.sq_SetStaticInt(0, 1);
    
    local currentChargeTime = obj.sq_GetStaticFloat(0);
    local maxChargeTime = obj.sq_GetStaticFloat(1);
    local baseDamageRate = obj.sq_GetStaticFloat(2);
    local maxDamageRate = obj.sq_GetStaticFloat(3);
    
    // 计算最终伤害倍率
    local chargeProgress = min(currentChargeTime / maxChargeTime, 1.0);
    local finalDamageRate = baseDamageRate + (maxDamageRate - baseDamageRate) * chargeProgress;
    
    // 计算额外MP消耗
    local extraMpCost = chargeProgress * 50;
    obj.sq_AddMp(-extraMpCost);
    
    // 设置释放动画
    obj.sq_SetCurrentAnimation(ANIMATION_CHARGE_RELEASE);
    
    // 存储最终参数
    obj.sq_SetStaticFloat(4, finalDamageRate);
    obj.sq_SetStaticFloat(5, chargeProgress);
    
    // 创建释放效果
    createChargeReleaseEffect(obj, chargeProgress);
    
    // 释放延迟
    obj.sq_SetMyShake(obj, 200, 100);
}

function onEndCurrentAni_ChargeAttack(obj)
{
    if (!obj) return;
    
    local chargePhase = obj.sq_GetStaticInt(0);
    
    if (chargePhase == 1) {
        // 执行蓄力攻击
        executeChargeAttack(obj);
        
        // 返回站立状态
        obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
    }
}

function executeChargeAttack(obj)
{
    if (!obj) return;
    
    local finalDamageRate = obj.sq_GetStaticFloat(4);
    local chargeProgress = obj.sq_GetStaticFloat(5);
    
    // 根据蓄力程度调整攻击范围
    local baseRange = 200;
    local finalRange = baseRange + chargeProgress * 100;
    
    // 获取攻击范围内的敌人
    local enemies = obj.sq_GetEnemiesInRange(obj.sq_GetPos(), finalRange);
    
    // 创建攻击效果
    createChargeAttackEffect(obj.sq_GetPos(), finalRange, chargeProgress);
    
    foreach (enemy in enemies) {
        if (!enemy) continue;
        
        // 计算伤害
        local damage = calculatePhysicalDamage(obj, enemy, finalDamageRate);
        
        // 蓄力满时有额外效果
        if (chargeProgress >= 1.0) {
            damage *= 1.2;  // 额外20%伤害
            
            // 添加特殊状态
            enemy.sq_AddBuff("DEBUFF_CHARGE_STUN", 2000);
        }
        
        // 造成伤害
        enemy.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
        
        // 击退效果(蓄力越高击退越远)
        local knockbackForce = 80 + chargeProgress * 120;
        local direction = getDirection(obj.sq_GetPos(), enemy.sq_GetPos());
        local knockback = sq_Vector3(
            direction.x * knockbackForce,
            direction.y * knockbackForce,
            chargeProgress * 100
        );
        enemy.sq_AddForce(knockback, 500 + chargeProgress * 300);
        
        // 创建命中效果
        createChargeHitEffect(enemy.sq_GetPos(), chargeProgress);
    }
    
    // 播放释放音效
    obj.sq_PlaySound("charge_release_sound");
    
    AdvancedLog(LogLevel.INFO, "CHARGE", 
               "Charge attack released: " + (chargeProgress * 100).tointeger() + 
               "% charge, hit " + enemies.len() + " enemies");
}

---

## 被动技能模板

### 触发型被动技能

```squirrel
// 触发型被动技能模板
// 适用于：反击、格挡反击等

function checkExecutableSkill_CounterPassive(obj)
{
    // 被动技能通常不需要主动检查
    return false;
}

function onSetState_CounterPassive(obj, state, datas, isResetTimer)
{
    // 被动技能通常不会主动进入状态
    return;
}

// 被动技能的核心：事件监听
function onTakeDamage_CounterPassive(obj, attacker, damage, damageType)
{
    if (!obj || !attacker) return damage;
    
    // 检查是否学习了反击被动
    if (!obj.sq_HasSkill("CounterPassive")) return damage;
    
    // 检查反击条件
    if (!canTriggerCounter(obj, attacker, damage)) return damage;
    
    // 触发反击
    triggerCounterAttack(obj, attacker, damage);
    
    return damage;
}

function canTriggerCounter(obj, attacker, damage)
{
    // 检查冷却时间
    if (!isSkillReady(obj, "CounterPassive", 3000)) return false;
    
    // 检查距离
    local distance = getDistance(obj.sq_GetPos(), attacker.sq_GetPos());
    if (distance > 150) return false;
    
    // 检查伤害阈值
    if (damage < obj.sq_GetMaxHP() * 0.05) return false;  // 至少5%最大HP的伤害
    
    // 概率触发(30%几率)
    if (random(100) >= 30) return false;
    
    return true;
}

function triggerCounterAttack(obj, attacker, originalDamage)
{
    if (!obj || !attacker) return;
    
    // 记录技能使用
    recordSkillUse(obj, "CounterPassive");
    
    // 面向攻击者
    local direction = getDirection(obj.sq_GetPos(), attacker.sq_GetPos());
    obj.sq_SetDirection(direction.x > 0 ? 1 : -1);
    
    // 设置反击动画
    obj.sq_SetCurrentAnimation(ANIMATION_COUNTER);
    
    // 计算反击伤害(基于受到的伤害)
    local counterDamage = originalDamage * 1.5;
    
    // 创建反击效果
    createCounterEffect(obj, attacker, "counter_attack_effect");
    
    // 延迟执行反击伤害
    obj.sq_SetTimer(200, function() {
        executeCounterDamage(obj, attacker, counterDamage);
    });
    
    AdvancedLog(LogLevel.INFO, "PASSIVE", 
               "Counter attack triggered: " + counterDamage + " damage");
}

function executeCounterDamage(obj, target, damage)
{
    if (!obj || !target) return;
    
    // 造成反击伤害
    target.sq_AddDamage(damage, obj, DAMAGE_TYPE_PHYSICAL);
    
    // 击退效果
    local direction = getDirection(obj.sq_GetPos(), target.sq_GetPos());
    local knockback = sq_Vector3(direction.x * 100, direction.y * 100, 50);
    target.sq_AddForce(knockback, 400);
    
    // 创建命中效果
    createHitEffect(target.sq_GetPos(), "counter_hit_effect");
    
    // 播放反击音效
    obj.sq_PlaySound("counter_hit_sound");
}
```

### 属性增强型被动技能

```squirrel
// 属性增强型被动技能模板
// 适用于：攻击力提升、暴击率提升等

function initPassiveSkill_AttributeBoost(obj)
{
    if (!obj) return;
    
    // 检查是否已经初始化
    if (obj.sq_GetStaticInt(PASSIVE_INIT_FLAG) == 1) return;
    
    // 标记已初始化
    obj.sq_SetStaticInt(PASSIVE_INIT_FLAG, 1);
    
    // 应用被动效果
    applyAttributeBoost(obj);
    
    AdvancedLog(LogLevel.INFO, "PASSIVE", "Attribute boost passive initialized");
}

function applyAttributeBoost(obj)
{
    if (!obj) return;
    
    // 获取技能等级
    local skillLevel = obj.sq_GetSkillLevel("AttributeBoost");
    if (skillLevel <= 0) return;
    
    // 计算属性加成
    local attackBonus = skillLevel * 0.05;      // 每级5%攻击力
    local critRateBonus = skillLevel * 2;       // 每级2%暴击率
    local critDamageBonus = skillLevel * 0.03;  // 每级3%暴击伤害
    
    // 应用属性修改
    local currentAttack = obj.sq_GetPhysicalAttack();
    local currentCritRate = obj.sq_GetCriticalRate();
    local currentCritDamage = obj.sq_GetCriticalDamage();
    
    obj.sq_SetPhysicalAttack(currentAttack * (1.0 + attackBonus));
    obj.sq_SetCriticalRate(currentCritRate + critRateBonus);
    obj.sq_SetCriticalDamage(currentCritDamage * (1.0 + critDamageBonus));
    
    // 保存原始值用于移除时恢复
    obj.sq_SetStaticFloat(PASSIVE_ORIGINAL_ATTACK, currentAttack);
    obj.sq_SetStaticFloat(PASSIVE_ORIGINAL_CRIT_RATE, currentCritRate);
    obj.sq_SetStaticFloat(PASSIVE_ORIGINAL_CRIT_DAMAGE, currentCritDamage);
    
    // 创建被动效果
    createPassiveEffect(obj, "attribute_boost_aura");
    
    AdvancedLog(LogLevel.INFO, "PASSIVE", 
               "Attribute boost applied: +" + (attackBonus * 100).tointeger() + 
               "% attack, +" + critRateBonus + "% crit rate");
}

function removeAttributeBoost(obj)
{
    if (!obj) return;
    
    // 恢复原始属性
    local originalAttack = obj.sq_GetStaticFloat(PASSIVE_ORIGINAL_ATTACK);
    local originalCritRate = obj.sq_GetStaticFloat(PASSIVE_ORIGINAL_CRIT_RATE);
    local originalCritDamage = obj.sq_GetStaticFloat(PASSIVE_ORIGINAL_CRIT_DAMAGE);
    
    obj.sq_SetPhysicalAttack(originalAttack);
    obj.sq_SetCriticalRate(originalCritRate);
    obj.sq_SetCriticalDamage(originalCritDamage);
    
    // 移除被动效果
    removePassiveEffect(obj, "attribute_boost_aura");
    
    // 清除初始化标记
    obj.sq_SetStaticInt(PASSIVE_INIT_FLAG, 0);
    
    AdvancedLog(LogLevel.INFO, "PASSIVE", "Attribute boost removed");
}

// 被动技能常量定义
const PASSIVE_INIT_FLAG = 10;
const PASSIVE_ORIGINAL_ATTACK = 11;
const PASSIVE_ORIGINAL_CRIT_RATE = 12;
const PASSIVE_ORIGINAL_CRIT_DAMAGE = 13;
```

---

## 组合技能模板

### 技能连锁系统

```squirrel
// 技能连锁系统模板
// 适用于：技能组合、连招系统等

local g_skillChainData = {};

function initSkillChain(obj)
{
    if (!obj) return;
    
    local objIndex = obj.sq_GetObjectIndex();
    
    // 初始化连锁数据
    g_skillChainData[objIndex] <- {
        currentChain = [],
        chainWindow = 0,
        maxChainLength = 5,
        chainBonus = 1.0
    };
}

function addSkillToChain(obj, skillName)
{
    if (!obj) return;
    
    local objIndex = obj.sq_GetObjectIndex();
    if (!(objIndex in g_skillChainData)) {
        initSkillChain(obj);
    }
    
    local chainData = g_skillChainData[objIndex];
    local currentTime = getCurrentTime();
    
    // 检查连锁时间窗口(3秒内)
    if (currentTime - chainData.chainWindow > 3000) {
        // 重置连锁
        chainData.currentChain.clear();
        chainData.chainBonus = 1.0;
    }
    
    // 添加技能到连锁
    chainData.currentChain.append(skillName);
    chainData.chainWindow = currentTime;
    
    // 限制连锁长度
    if (chainData.currentChain.len() > chainData.maxChainLength) {
        chainData.currentChain.remove(0);
    }
    
    // 计算连锁奖励
    updateChainBonus(obj);
    
    // 检查特殊连锁组合
    checkSpecialChainCombos(obj);
}

function updateChainBonus(obj)
{
    if (!obj) return;
    
    local objIndex = obj.sq_GetObjectIndex();
    local chainData = g_skillChainData[objIndex];
    local chainLength = chainData.currentChain.len();
    
    // 计算连锁伤害奖励
    chainData.chainBonus = 1.0 + (chainLength - 1) * 0.1;  // 每个连锁+10%伤害
    
    // 应用连锁BUFF
    if (chainLength >= 2) {
        obj.sq_AddBuff("BUFF_SKILL_CHAIN", 3000);
        
        // 更新BUFF强度
        local buff = obj.sq_GetBuff("BUFF_SKILL_CHAIN");
        if (buff) {
            buff.sq_SetStaticFloat(0, chainData.chainBonus);
            buff.sq_SetStaticInt(0, chainLength);
        }
    }
    
    // 创建连锁效果
    createChainEffect(obj, chainLength);
    
    AdvancedLog(LogLevel.INFO, "CHAIN", 
               "Skill chain updated: " + chainLength + " skills, " + 
               (chainData.chainBonus * 100).tointeger() + "% damage");
}

function checkSpecialChainCombos(obj)
{
    if (!obj) return;
    
    local objIndex = obj.sq_GetObjectIndex();
    local chainData = g_skillChainData[objIndex];
    local chain = chainData.currentChain;
    
    // 检查各种特殊组合
    if (isChainMatch(chain, ["BasicAttack", "MagicMissile", "CircleAttack"])) {
        // 魔法连击组合
        triggerSpecialCombo(obj, "MagicCombo");
    } else if (isChainMatch(chain, ["Dash", "TripleCombo"])) {
        // 突进连击组合
        triggerSpecialCombo(obj, "RushCombo");
    } else if (isChainMatch(chain, ["SelfBuff", "ChargeAttack"])) {
        // 强化蓄力组合
        triggerSpecialCombo(obj, "PowerCombo");
    }
}

function isChainMatch(currentChain, targetPattern)
{
    if (currentChain.len() < targetPattern.len()) return false;
    
    // 检查最后几个技能是否匹配模式
    local startIndex = currentChain.len() - targetPattern.len();
    
    for (local i = 0; i < targetPattern.len(); i++) {
        if (currentChain[startIndex + i] != targetPattern[i]) {
            return false;
        }
    }
    
    return true;
}

function triggerSpecialCombo(obj, comboType)
{
    if (!obj) return;
    
    switch (comboType) {
        case "MagicCombo":
            executeMagicCombo(obj);
            break;
        case "RushCombo":
            executeRushCombo(obj);
            break;
        case "PowerCombo":
            executePowerCombo(obj);
            break;
    }
}

function executeMagicCombo(obj)
{
    if (!obj) return;
    
    // 魔法连击：在周围创建多个魔法爆炸
    local centerPos = obj.sq_GetPos();
    
    for (local i = 0; i < 5; i++) {
        local angle = i * 72;  // 五角星形状
        local distance = 150;
        
        local explosionPos = sq_Vector3(
            centerPos.x + distance * cos(angle * PI / 180),
            centerPos.y + distance * sin(angle * PI / 180),
            centerPos.z
        );
        
        // 延迟爆炸
        obj.sq_SetTimer(i * 200, function() {
            createMagicExplosion(explosionPos, obj);
        });
    }
    
    // 创建特殊连击效果
    createSpecialComboEffect(obj, "magic_combo_effect");
    
    AdvancedLog(LogLevel.INFO, "COMBO", "Magic combo triggered");
}

function executeRushCombo(obj)
{
    if (!obj) return;
    
    // 突进连击：获得短暂的超高速移动和攻击力
    obj.sq_AddBuff("BUFF_RUSH_COMBO", 5000);
    
    local buff = obj.sq_GetBuff("BUFF_RUSH_COMBO");
    if (buff) {
        // 设置BUFF效果
        buff.sq_SetStaticFloat(0, 2.0);  // 2倍移动速度
        buff.sq_SetStaticFloat(1, 1.5);  // 1.5倍攻击力
        
        // 应用效果
        obj.sq_SetMoveSpeed(obj.sq_GetMoveSpeed() * 2.0);
        obj.sq_SetPhysicalAttack(obj.sq_GetPhysicalAttack() * 1.5);
    }
    
    // 创建特殊连击效果
    createSpecialComboEffect(obj, "rush_combo_effect");
    
    AdvancedLog(LogLevel.INFO, "COMBO", "Rush combo triggered");
}

function executePowerCombo(obj)
{
    if (!obj) return;
    
    // 强化蓄力连击：下一个技能无需蓄力且威力翻倍
    obj.sq_AddBuff("BUFF_POWER_COMBO", 10000);
    
    local buff = obj.sq_GetBuff("BUFF_POWER_COMBO");
    if (buff) {
        // 设置BUFF效果
        buff.sq_SetStaticFloat(0, 2.0);  // 2倍伤害
        buff.sq_SetStaticInt(0, 1);      // 免蓄力标记
    }
    
    // 创建特殊连击效果
    createSpecialComboEffect(obj, "power_combo_effect");
    
    AdvancedLog(LogLevel.INFO, "COMBO", "Power combo triggered");
}

---

## 特殊效果技能模板

### 时间操控技能

```squirrel
// 时间操控技能模板
// 适用于：时间减缓、时间加速等

function checkExecutableSkill_TimeControl(obj)
{
    if (!obj) return false;
    
    // 检查MP消耗
    local mpCost = 150;
    if (obj.sq_GetMp() < mpCost) return false;
    
    // 检查冷却时间
    if (!isSkillReady(obj, "TimeControl", 30000)) return false;
    
    return true;
}

function onSetState_TimeControl(obj, state, datas, isResetTimer)
{
    if (!obj) return;
    
    // 消耗MP
    local mpCost = 150;
    obj.sq_AddMp(-mpCost);
    
    // 记录技能使用
    recordSkillUse(obj, "TimeControl");
    
    // 设置时间操控动画
    obj.sq_SetCurrentAnimation(ANIMATION_TIME_CONTROL);
    
    // 设置时间操控参数
    obj.sq_SetStaticFloat(0, 300.0);    // 影响范围
    obj.sq_SetStaticFloat(1, 0.3);      // 时间减缓倍率(30%速度)
    obj.sq_SetStaticInt(0, 8000);       // 持续时间
    
    // 施法时间
    obj.sq_SetMyShake(obj, 300, 150);
}

function onEndCurrentAni_TimeControl(obj)
{
    if (!obj) return;
    
    // 执行时间操控
    executeTimeControl(obj);
    
    // 返回站立状态
    obj.sq_AddSetStatePacket(STATE_STAND, STATE_PRIORITY_USER, false);
}

function executeTimeControl(obj)
{
    if (!obj) return;
    
    local range = obj.sq_GetStaticFloat(0);
    local timeRate = obj.sq_GetStaticFloat(1);
    local duration = obj.sq_GetStaticInt(0);
    local centerPos = obj.sq_GetPos();
    
    // 创建时间场效果
    createTimeFieldEffect(centerPos, range, "time_control_field");
    
    // 获取范围内的所有敌人
    local enemies = obj.sq_GetEnemiesInRange(centerPos, range);
    
    foreach (enemy in enemies) {
        if (!enemy) continue;
        
        // 应用时间减缓BUFF
        local timeBuff = enemy.sq_AddBuff("DEBUFF_TIME_SLOW", duration);
        
        if (timeBuff) {
            // 设置时间减缓效果
            timeBuff.sq_SetStaticFloat(0, timeRate);
            
            // 应用速度减缓
            local currentMoveSpeed = enemy.sq_GetMoveSpeed();
            local currentAttackSpeed = enemy.sq_GetAttackSpeed();
            
            enemy.sq_SetMoveSpeed(currentMoveSpeed * timeRate);
            enemy.sq_SetAttackSpeed(currentAttackSpeed * timeRate);
            
            // 创建个体时间效果
            createTimeSlowEffect(enemy, "time_slow_effect", duration);
        }
    }
    
    // 播放时间操控音效
    obj.sq_PlaySound("time_control_sound");
    
    AdvancedLog(LogLevel.INFO, "TIME", 
               "Time control activated, affected " + enemies.len() + " enemies");
}

// 时间减缓BUFF结束处理
function onBuffEnd_TimeControl(obj, buff)
{
    if (!obj || !buff) return;
    
    local timeRate = buff.sq_GetStaticFloat(0);
    
    // 恢复正常速度
    local currentMoveSpeed = obj.sq_GetMoveSpeed();
    local currentAttackSpeed = obj.sq_GetAttackSpeed();
    
    obj.sq_SetMoveSpeed(currentMoveSpeed / timeRate);
    obj.sq_SetAttackSpeed(currentAttackSpeed / timeRate);
    
    // 移除时间效果
    removeTimeSlowEffect(obj, "time_slow_effect");
}
```

---

## 总结

这个技能模板集合提供了DNF中常见技能类型的完整实现模板，包括：

### 🎯 **核心特性**
- **模块化设计** - 每个模板都是独立的，可以单独使用或组合
- **参数化配置** - 通过修改参数轻松调整技能效果
- **完整的生命周期** - 从检查条件到执行效果的完整流程
- **错误处理** - 包含必要的安全检查和错误处理
- **日志记录** - 详细的调试和监控信息

### 📚 **模板分类**
1. **基础攻击** - 单体物理/魔法攻击
2. **范围攻击** - 圆形/扇形范围攻击
3. **BUFF技能** - 自身/团队增益效果
4. **召唤技能** - 召唤生物/陷阱系统
5. **位移技能** - 瞬移/冲刺移动
6. **连击技能** - 多段连续攻击
7. **蓄力技能** - 可变威力蓄力系统
8. **被动技能** - 触发型/属性增强被动
9. **组合技能** - 技能连锁组合系统
10. **特殊效果** - 时间操控等特殊机制

### 🔧 **使用方法**
1. 选择合适的模板作为基础
2. 根据需求修改参数和效果
3. 添加自定义的视觉和音效
4. 测试和调优技能平衡性

这些模板为NUT脚本开发提供了坚实的基础，可以大大加速技能开发过程。