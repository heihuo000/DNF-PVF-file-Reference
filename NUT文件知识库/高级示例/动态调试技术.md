# 动态调试技术详解

基于DAF学院教程的NUT脚本动态调试方法，实现不重启游戏的实时开发调试。

## 🎯 核心原理

动态调试技术通过`dofile`语句在每次技能释放时重新加载外部脚本文件，从而实现代码的实时更新，无需重启游戏客户端。

## 📁 文件结构

```
dnf.exe目录/
├── test.nut          # 外部调试文件
└── Script/
    └── skill/
        └── xxx.nut   # 技能主文件
```

## 🔧 实现步骤

### 1. 创建外部调试文件

在`dnf.exe`目录下创建`test.nut`文件：

```nut
// test.nut - 外部调试文件
// 此文件可以实时修改，无需重启游戏

// 技能状态定义
STATE_DEBUG_SKILL <- 200

// 调试用的技能实现
function debugSkillLogic(obj)
{
    if(!obj) return;
    
    // 在这里编写实际的技能逻辑
    obj.sq_SetCurrentAnimation(ANIMATION_ATTACK);
    obj.sq_StopMove();
    
    // 创建攻击判定
    obj.sq_StartWrite();
    obj.sq_WriteDword(1);  // 攻击方向
    obj.sq_SendCreatePassiveObjectPacket(24100, 0, 0, 0, 0);
    
    // 输出调试信息
    print(`[DEBUG] 技能释放成功`);
}

// 调试用的伤害计算
function debugCalculateDamage(obj, skillLevel)
{
    if(!obj) return 0;
    
    local baseDamage = 1000;
    local levelBonus = skillLevel * 100;
    local finalDamage = baseDamage + levelBonus;
    
    print(`[DEBUG] 基础伤害: ` + baseDamage + `, 等级加成: ` + levelBonus + `, 最终伤害: ` + finalDamage);
    
    return finalDamage;
}

// 调试用的特效创建
function debugCreateEffect(obj, effectId)
{
    if(!obj) return;
    
    obj.sq_StartWrite();
    obj.sq_WriteDword(effectId);
    obj.sq_SendCreatePassiveObjectPacket(24200, 0, 0, 0, 0);
    
    print(`[DEBUG] 创建特效: ` + effectId);
}
```

### 2. 修改技能主文件

在技能的主要函数中调用外部文件：

```nut
// 技能主文件中的实现
function onSetState_TestSkill(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 动态加载外部调试文件
    dofile(`test.nut`);
    
    // 调用外部定义的函数
    debugSkillLogic(obj);
}

function onKeyFrameFlag_TestSkill(obj, flagIndex)
{
    if(!obj) return;
    
    // 动态加载外部调试文件
    dofile(`test.nut`);
    
    if(flagIndex == 1)
    {
        // 调用外部的伤害计算
        local damage = debugCalculateDamage(obj, 10);
        obj.sq_SetDamage(damage);
        
        // 调用外部的特效创建
        debugCreateEffect(obj, 1001);
    }
}
```

## 🚀 高级应用

### 1. 条件调试

```nut
// test.nut
DEBUG_MODE <- true  // 调试开关

function conditionalDebug(obj, message)
{
    if(DEBUG_MODE)
    {
        print(`[DEBUG] ` + message);
        
        // 在调试模式下显示额外信息
        print(`[DEBUG] 对象状态: ` + obj.sq_GetState());
        print(`[DEBUG] 当前HP: ` + obj.sq_GetHp());
        print(`[DEBUG] 当前MP: ` + obj.sq_GetMp());
    }
}

function debugSkillWithCondition(obj)
{
    conditionalDebug(obj, `开始执行技能`);
    
    if(!obj) 
    {
        conditionalDebug(obj, `对象无效，技能执行失败`);
        return;
    }
    
    // 技能逻辑
    obj.sq_SetCurrentAnimation(ANIMATION_SKILL);
    conditionalDebug(obj, `设置动画完成`);
    
    obj.sq_StopMove();
    conditionalDebug(obj, `停止移动完成`);
}
```

### 2. 参数化调试

```nut
// test.nut
// 可调试的参数配置
DEBUG_CONFIG <- {
    damage_multiplier = 1.5,
    effect_scale = 2.0,
    animation_speed = 1.2,
    debug_output = true
}

function parameterizedSkill(obj, skillLevel)
{
    if(!obj) return;
    
    // 使用可调试的参数
    local baseDamage = 1000 * DEBUG_CONFIG.damage_multiplier;
    local finalDamage = baseDamage * skillLevel;
    
    if(DEBUG_CONFIG.debug_output)
    {
        print(`[DEBUG] 伤害倍率: ` + DEBUG_CONFIG.damage_multiplier);
        print(`[DEBUG] 最终伤害: ` + finalDamage);
    }
    
    // 设置动画速度
    obj.sq_SetStaticSpeedInfo(SPEED_TYPE_ATTACK_SPEED, 
        SPEED_TYPE_ATTACK_SPEED, SPEED_VALUE_DEFAULT, 
        SPEED_VALUE_DEFAULT, DEBUG_CONFIG.animation_speed, DEBUG_CONFIG.animation_speed);
    
    // 创建可缩放的特效
    obj.sq_StartWrite();
    obj.sq_WriteDword(DEBUG_CONFIG.effect_scale.tointeger());
    obj.sq_SendCreatePassiveObjectPacket(24300, 0, 0, 0, 0);
}
```

### 3. 多版本测试

```nut
// test.nut
SKILL_VERSION <- 3  // 切换不同版本的实现

function multiVersionSkill(obj)
{
    if(!obj) return;
    
    switch(SKILL_VERSION)
    {
        case 1:
            // 版本1：基础实现
            skillVersion1(obj);
            break;
            
        case 2:
            // 版本2：增强实现
            skillVersion2(obj);
            break;
            
        case 3:
            // 版本3：实验性实现
            skillVersion3(obj);
            break;
            
        default:
            print(`[ERROR] 未知的技能版本: ` + SKILL_VERSION);
            break;
    }
}

function skillVersion1(obj)
{
    print(`[DEBUG] 执行技能版本1`);
    obj.sq_SetCurrentAnimation(ANIMATION_ATTACK1);
    // 基础逻辑
}

function skillVersion2(obj)
{
    print(`[DEBUG] 执行技能版本2`);
    obj.sq_SetCurrentAnimation(ANIMATION_ATTACK2);
    // 增强逻辑
}

function skillVersion3(obj)
{
    print(`[DEBUG] 执行技能版本3`);
    obj.sq_SetCurrentAnimation(ANIMATION_ATTACK3);
    // 实验性逻辑
}
```

## ⚠️ 注意事项

### 1. 性能考虑
- `dofile`会重新解析整个文件，频繁调用可能影响性能
- 建议在发布版本中移除`dofile`调用
- 可以通过条件编译控制调试代码

### 2. 文件路径
- 外部文件必须放在`dnf.exe`目录下
- 使用相对路径引用文件
- 确保文件编码为UTF-8或ANSI

### 3. 错误处理
```nut
function safeDofile(filename)
{
    try
    {
        dofile(filename);
        return true;
    }
    catch(error)
    {
        print(`[ERROR] 加载文件失败: ` + filename + `, 错误: ` + error);
        return false;
    }
}

function onSetState_SafeSkill(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 安全加载外部文件
    if(safeDofile(`test.nut`))
    {
        debugSkillLogic(obj);
    }
    else
    {
        // 使用默认实现
        defaultSkillLogic(obj);
    }
}
```

## 🎯 最佳实践

1. **模块化设计**: 将不同功能分离到不同的调试函数中
2. **版本控制**: 使用版本号管理不同的实现方案
3. **日志输出**: 详细记录调试信息，便于问题定位
4. **参数化配置**: 使用配置表控制调试参数
5. **错误恢复**: 提供默认实现作为备选方案

## 📝 调试工作流

1. **编写初版代码** → 在技能文件中实现基础逻辑
2. **提取调试逻辑** → 将可变部分移至`test.nut`
3. **实时调试** → 修改`test.nut`并在游戏中测试
4. **版本迭代** → 通过版本切换测试不同方案
5. **最终整合** → 将稳定版本整合回主文件

---

*基于DAF学院教程整理，专注于NUT脚本的高效开发调试*