# 函数合并技术详解

基于DAF学院教程的NUT脚本函数合并方法，解决多MOD冲突问题。

## 🎯 问题背景

当多个MOD使用相同的回调函数时，后加载的MOD会覆盖先加载的MOD的函数，导致功能冲突。函数合并技术可以将多个MOD的功能整合到一个函数中。

## 🔍 冲突识别

### 常见冲突函数
```nut
// 角色回调函数
drawMainCustomUI_Swordman()     // 主界面UI绘制
drawCustomUI_Swordman()         // 自定义UI绘制
onStartDungeon_Swordman()       // 进入地下城
onStartMap_Swordman()           // 进入地图
procAppend_Swordman()           // 角色处理函数
onAttack_Swordman()             // 攻击回调

// 技能回调函数
onSetState_SkillName()          // 技能状态设置
onKeyFrameFlag_SkillName()      // 关键帧事件
onAttack_SkillName()            // 技能攻击判定
```

### 冲突示例
```nut
// MOD A - 血条显示
function drawCustomUI_Swordman(obj)
{
    if(!obj) return;
    drawBloodBar(obj);
}

// MOD B - 技能冷却显示（会覆盖MOD A）
function drawCustomUI_Swordman(obj)
{
    if(!obj) return;
    drawSkillCooldown(obj);
}

// 结果：只有技能冷却显示生效，血条显示失效
```

## 🔧 合并方法

### 1. 基础合并

```nut
// 合并后的函数
function drawCustomUI_Swordman(obj)
{
    if(!obj) return;
    
    // 合并MOD A的功能
    drawBloodBar(obj);
    
    // 合并MOD B的功能
    drawSkillCooldown(obj);
    
    // 可以继续添加更多MOD的功能
    drawBuffIcons(obj);
    drawDamageCounter(obj);
}
```

### 2. 条件合并

```nut
// 带条件判断的合并
function onStartDungeon_Swordman(obj)
{
    if(!obj) return;
    
    // MOD A：特定地下城的功能
    local dungeonId = obj.sq_GetCurrentDungeonId();
    if(dungeonId == 1001 || dungeonId == 1002)
    {
        initSpecialDungeonFeatures(obj);
    }
    
    // MOD B：通用功能
    initCommonFeatures(obj);
    
    // MOD C：职业特定功能
    local job = obj.sq_GetJob();
    if(job == JOB_SWORDMAN)
    {
        initSwordmanFeatures(obj);
    }
}
```

### 3. 优先级合并

```nut
// 按优先级执行的合并
function procAppend_Swordman(obj)
{
    if(!obj) return;
    
    // 高优先级：核心功能（必须执行）
    coreProcessing(obj);
    
    // 中优先级：增强功能
    try
    {
        enhancedProcessing(obj);
    }
    catch(error)
    {
        print(`[WARNING] 增强功能执行失败: ` + error);
    }
    
    // 低优先级：可选功能
    try
    {
        optionalProcessing(obj);
    }
    catch(error)
    {
        print(`[INFO] 可选功能跳过: ` + error);
    }
}
```

## 🚀 高级合并技术

### 1. 模块化合并

```nut
// 定义模块接口
MODULE_REGISTRY <- {}

// 注册模块
function registerModule(name, moduleFunc)
{
    MODULE_REGISTRY[name] <- moduleFunc;
}

// 执行所有模块
function executeAllModules(obj, functionName)
{
    foreach(name, moduleFunc in MODULE_REGISTRY)
    {
        try
        {
            moduleFunc(obj, functionName);
        }
        catch(error)
        {
            print(`[ERROR] 模块 ` + name + ` 执行失败: ` + error);
        }
    }
}

// 注册各个MOD的模块
registerModule(`BloodBarMod`, function(obj, funcName) {
    if(funcName == `drawCustomUI` && obj)
        drawBloodBar(obj);
});

registerModule(`SkillCooldownMod`, function(obj, funcName) {
    if(funcName == `drawCustomUI` && obj)
        drawSkillCooldown(obj);
});

// 统一的回调函数
function drawCustomUI_Swordman(obj)
{
    executeAllModules(obj, `drawCustomUI`);
}
```

### 2. 事件驱动合并

```nut
// 事件系统
EVENT_HANDLERS <- {}

// 注册事件处理器
function addEventListener(eventName, handler)
{
    if(!(eventName in EVENT_HANDLERS))
        EVENT_HANDLERS[eventName] <- [];
    
    EVENT_HANDLERS[eventName].append(handler);
}

// 触发事件
function triggerEvent(eventName, obj, data = null)
{
    if(eventName in EVENT_HANDLERS)
    {
        foreach(handler in EVENT_HANDLERS[eventName])
        {
            try
            {
                handler(obj, data);
            }
            catch(error)
            {
                print(`[ERROR] 事件处理器执行失败: ` + error);
            }
        }
    }
}

// 注册各种事件处理器
addEventListener(`onDungeonStart`, function(obj, data) {
    initBloodBarSystem(obj);
});

addEventListener(`onDungeonStart`, function(obj, data) {
    initSkillCooldownSystem(obj);
});

addEventListener(`onDungeonStart`, function(obj, data) {
    initBuffSystem(obj);
});

// 统一的回调函数
function onStartDungeon_Swordman(obj)
{
    triggerEvent(`onDungeonStart`, obj);
}
```

### 3. 配置驱动合并

```nut
// 功能配置表
FEATURE_CONFIG <- {
    bloodBar = {
        enabled = true,
        priority = 1,
        func = drawBloodBar
    },
    skillCooldown = {
        enabled = true,
        priority = 2,
        func = drawSkillCooldown
    },
    buffIcons = {
        enabled = false,  // 可以通过配置禁用
        priority = 3,
        func = drawBuffIcons
    }
}

// 按配置执行功能
function executeConfiguredFeatures(obj, featureType)
{
    // 获取启用的功能并按优先级排序
    local enabledFeatures = [];
    foreach(name, config in FEATURE_CONFIG)
    {
        if(config.enabled)
        {
            enabledFeatures.append({
                name = name,
                priority = config.priority,
                func = config.func
            });
        }
    }
    
    // 按优先级排序
    enabledFeatures.sort(function(a, b) {
        return a.priority <=> b.priority;
    });
    
    // 执行功能
    foreach(feature in enabledFeatures)
    {
        try
        {
            feature.func(obj);
        }
        catch(error)
        {
            print(`[ERROR] 功能 ` + feature.name + ` 执行失败: ` + error);
        }
    }
}

// 统一的回调函数
function drawCustomUI_Swordman(obj)
{
    executeConfiguredFeatures(obj, `ui`);
}
```

## 🛠️ 实战案例

### 案例1：技能状态合并

```nut
// 多个MOD修改同一个技能的状态设置
function onSetState_Slash(obj, state, datas, isResetTimer)
{
    if(!obj) return;
    
    // 原版功能
    obj.sq_SetCurrentAnimation(ANIMATION_SLASH);
    obj.sq_StopMove();
    
    // MOD A：添加特效
    if(hasModA())
    {
        obj.sq_StartWrite();
        obj.sq_WriteDword(1001);  // 特效ID
        obj.sq_SendCreatePassiveObjectPacket(24100, 0, 0, 0, 0);
    }
    
    // MOD B：修改伤害
    if(hasModB())
    {
        local damage = obj.sq_GetIntData(SKILL_SLASH, SKL_BASIC_DAMAGE);
        damage = damage * 1.5;  // 增加50%伤害
        obj.sq_SetDamage(damage);
    }
    
    // MOD C：添加BUFF
    if(hasModC())
    {
        sq_AppendAppendage(obj, obj, APPENDAGE_SLASH_BUFF, true, `slash_buff.ap`, true);
    }
}

// MOD检测函数
function hasModA() { return true; }  // 根据实际情况实现
function hasModB() { return true; }
function hasModC() { return true; }
```

### 案例2：攻击判定合并

```nut
// 多个MOD修改攻击判定
function onAttack_Swordman(obj, damager, boundingBox, isStuck)
{
    if(!obj || !damager) return;
    
    // 原版攻击处理
    local damage = damager.sq_GetDamage();
    local attackType = damager.sq_GetAttackType();
    
    // MOD A：暴击系统
    if(hasModA())
    {
        local critChance = obj.sq_GetBonusRateWithPassive(CRITICAL_HIT);
        if(sq_Rand(0, 100) < critChance)
        {
            damage = damage * 2;  // 暴击伤害
            // 显示暴击特效
            obj.sq_StartWrite();
            obj.sq_WriteDword(2001);  // 暴击特效ID
            obj.sq_SendCreatePassiveObjectPacket(24200, 0, 0, 0, 0);
        }
    }
    
    // MOD B：元素伤害
    if(hasModB())
    {
        local elementType = getWeaponElement(obj);
        if(elementType != ELEMENT_NONE)
        {
            local elementDamage = damage * 0.3;  // 30%元素伤害
            damager.sq_SetElementalDamage(elementType, elementDamage);
        }
    }
    
    // MOD C：连击系统
    if(hasModC())
    {
        incrementComboCounter(obj);
        local comboBonus = getComboBonus(obj);
        damage = damage * comboBonus;
    }
    
    // 应用最终伤害
    damager.sq_SetDamage(damage);
}
```

## ⚠️ 注意事项

### 1. 执行顺序
- 某些功能对执行顺序敏感
- 使用优先级系统控制执行顺序
- 核心功能优先，装饰功能其次

### 2. 错误隔离
```nut
function safeExecuteFunction(func, obj, errorMessage)
{
    try
    {
        func(obj);
    }
    catch(error)
    {
        print(`[ERROR] ` + errorMessage + `: ` + error);
        // 不影响其他功能的执行
    }
}
```

### 3. 性能考虑
- 避免在高频回调中执行复杂逻辑
- 使用缓存减少重复计算
- 及时清理不需要的功能

### 4. 兼容性检查
```nut
function checkModCompatibility()
{
    local conflicts = [];
    
    // 检查版本兼容性
    if(getModVersion(`ModA`) < 2.0 && getModVersion(`ModB`) > 3.0)
    {
        conflicts.append(`ModA版本过低，与ModB不兼容`);
    }
    
    // 检查功能冲突
    if(hasFeature(`CustomUI`) && hasFeature(`AlternativeUI`))
    {
        conflicts.append(`UI功能冲突`);
    }
    
    return conflicts;
}
```

## 🎯 最佳实践

1. **文档化**: 详细记录每个MOD的功能和依赖
2. **模块化**: 将功能拆分为独立的模块
3. **配置化**: 提供开关控制各个功能
4. **测试**: 充分测试合并后的功能
5. **向后兼容**: 保持与原版功能的兼容性

## 📝 合并工作流

1. **分析冲突** → 识别冲突的函数和功能
2. **设计架构** → 选择合适的合并方案
3. **实现合并** → 编写合并后的函数
4. **测试验证** → 确保所有功能正常工作
5. **优化性能** → 优化执行效率和稳定性

---

*基于DAF学院教程整理，专注于解决NUT脚本的MOD冲突问题*