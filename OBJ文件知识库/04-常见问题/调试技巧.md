# 调试技巧

## 🔧 基础调试方法

### 逐步排查法

#### 1. 文件加载测试
```
步骤1: 检查文件是否能正常加载
- 将OBJ文件放入正确目录
- 启动游戏，观察是否有错误提示
- 检查游戏日志文件

步骤2: 验证基础语法
- 确认文件头 #PVF_File 存在
- 检查所有标签格式正确
- 验证字符串使用反引号

步骤3: 测试最小配置
- 只保留必需标签 [name]
- 逐步添加其他属性
- 每次添加后测试效果
```

#### 2. 二分查找法
```
当文件较大且问题不明确时：

1. 备份原文件
2. 删除一半内容，测试是否正常
3. 如果正常，问题在删除的部分
4. 如果异常，问题在保留的部分
5. 重复此过程直到找到问题行
```

### 常见错误定位

#### 语法错误快速定位
```python
# 快速语法检查脚本
def quick_syntax_check(filepath):
    with open(filepath, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    errors = []
    
    # 检查关键问题
    for i, line in enumerate(lines, 1):
        # 双引号检查
        if '"' in line and not line.strip().startswith('#'):
            errors.append(f"第{i}行: 双引号错误")
        
        # 空格缩进检查
        if line.startswith('  ') and not line.startswith('\t'):
            errors.append(f"第{i}行: 空格缩进错误")
        
        # 标签格式检查
        if '[' in line and ']' not in line:
            errors.append(f"第{i}行: 标签未闭合")
    
    return errors
```

## 🎯 专项调试技巧

### 动画相关问题

#### 问题现象
- 对象不显示
- 动画播放异常
- 帧率问题

#### 调试步骤
```
1. 检查ACT文件引用
   [basic action]
   `Action/test.act`  # 确认路径正确

2. 验证ACT文件存在
   - 检查文件是否存在
   - 确认文件名大小写
   - 验证文件内容格式

3. 测试简单动画
   # 使用最简单的ACT文件测试
   [basic action]
   `Action/simple_flash.act`

4. 逐帧检查
   - 确认每帧图像存在
   - 检查帧时间设置
   - 验证循环设置
```

#### 调试用ACT文件
```
#PVF_File

[frame max]
2

[frame 0]
	[image]
		`common/commoneffect/dust/dust.img`
		0
	[image pos]
		0	0
	[delay]
		100

[frame 1]
	[image]
		`common/commoneffect/dust/dust.img`
		1
	[image pos]
		0	0
	[delay]
		100
```

### 攻击判定问题

#### 问题现象
- 攻击无效果
- 伤害计算错误
- 判定范围异常

#### 调试步骤
```
1. 检查ATK文件引用
   [attack info]
   `AttackInfo/test.atk`

2. 验证攻击属性
   - 检查伤害值设置
   - 确认攻击类型
   - 验证判定范围

3. 测试基础攻击
   # 使用简单的ATK配置
   [attack info]
   `AttackInfo/basic_attack.atk`

4. 逐项验证
   - 伤害计算公式
   - 属性加成效果
   - 特殊效果触发
```

#### 调试用ATK文件
```
#PVF_File

[damage]
100

[attack type]
`[magic]`

[weapon damage apply]
1

[attack direction]
`[auto]`

[hit info]
	[blow]
		`[up]`
		200	200
	[blood]
		`[normal]`
```

### 层级显示问题

#### 问题现象
- 对象被遮挡
- 显示顺序错误
- 层级冲突

#### 调试方法
```
1. 理解层级系统
   [layer]
   `[bottom]`   # 最底层
   `[normal]`   # 普通层
   `[cover]`    # 覆盖层

2. 测试不同层级
   # 逐个测试每个层级的显示效果
   
3. 调整层级数值
   [layer level]
   0    # 较低优先级
   50   # 中等优先级
   100  # 较高优先级

4. 检查冲突
   # 确保同层级对象的优先级设置合理
```

## 🛠️ 调试工具使用

### 游戏内调试

#### 开发者模式
```
1. 启用调试模式
   - 修改游戏配置文件
   - 启用开发者选项
   - 打开调试信息显示

2. 实时监控
   - 查看对象创建日志
   - 监控性能指标
   - 观察内存使用

3. 参数调整
   - 实时修改对象属性
   - 测试不同参数组合
   - 观察效果变化
```

#### 日志分析
```
常见日志信息：

[ERROR] Failed to load: passiveobject/test.obj
原因: 文件路径错误或语法错误

[WARNING] Missing animation file: Action/test.act
原因: ACT文件不存在

[INFO] Object created: test_object (ID: 12345)
说明: 对象创建成功

[DEBUG] Animation frame: 5/10
说明: 动画播放状态
```

### 外部调试工具

#### 文件监控工具
```python
# 文件变化监控脚本
import os
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class OBJFileHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if event.src_path.endswith('.obj'):
            print(f"OBJ文件已修改: {event.src_path}")
            # 自动执行格式检查
            check_file_format(event.src_path)
    
    def on_created(self, event):
        if event.src_path.endswith('.obj'):
            print(f"新OBJ文件创建: {event.src_path}")

def monitor_directory(path):
    event_handler = OBJFileHandler()
    observer = Observer()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# 使用方法
monitor_directory("./passiveobject/")
```

#### 性能分析工具
```python
# 性能分析脚本
import time
import psutil
import matplotlib.pyplot as plt

class PerformanceMonitor:
    def __init__(self):
        self.cpu_usage = []
        self.memory_usage = []
        self.timestamps = []
    
    def start_monitoring(self, duration=60):
        start_time = time.time()
        
        while time.time() - start_time < duration:
            # 记录CPU和内存使用率
            cpu = psutil.cpu_percent()
            memory = psutil.virtual_memory().percent
            timestamp = time.time() - start_time
            
            self.cpu_usage.append(cpu)
            self.memory_usage.append(memory)
            self.timestamps.append(timestamp)
            
            time.sleep(1)
    
    def generate_report(self):
        plt.figure(figsize=(12, 6))
        
        plt.subplot(2, 1, 1)
        plt.plot(self.timestamps, self.cpu_usage)
        plt.title('CPU使用率')
        plt.ylabel('百分比 (%)')
        
        plt.subplot(2, 1, 2)
        plt.plot(self.timestamps, self.memory_usage)
        plt.title('内存使用率')
        plt.xlabel('时间 (秒)')
        plt.ylabel('百分比 (%)')
        
        plt.tight_layout()
        plt.savefig('performance_report.png')
        plt.show()

# 使用方法
monitor = PerformanceMonitor()
monitor.start_monitoring(120)  # 监控2分钟
monitor.generate_report()
```

## 📋 调试检查清单

### 文件级检查
```
□ 文件编码为UTF-8
□ 文件头 #PVF_File 存在
□ 所有字符串使用反引号
□ 缩进使用Tab而非空格
□ 标签格式正确且配对
□ 必需标签 [name] 存在
□ 文件路径引用正确
□ 依赖文件存在
```

### 功能级检查
```
□ 对象能正常创建
□ 动画播放正常
□ 攻击判定有效
□ 层级显示正确
□ 生命周期符合预期
□ 性能表现良好
□ 无内存泄漏
□ 兼容性测试通过
```

### 测试用例
```
□ 最小配置测试
□ 完整功能测试
□ 边界条件测试
□ 异常情况测试
□ 性能压力测试
□ 兼容性测试
□ 回归测试
□ 用户验收测试
```

## 🚨 紧急问题处理

### 游戏崩溃
```
1. 立即备份当前文件
2. 恢复到最后一个稳定版本
3. 逐步重新应用修改
4. 定位导致崩溃的具体更改
5. 修复问题后重新测试
```

### 性能问题
```
1. 使用性能监控工具
2. 识别性能瓶颈
3. 优化资源使用
4. 减少不必要的计算
5. 测试优化效果
```

### 兼容性问题
```
1. 确认游戏版本
2. 检查文件格式版本
3. 验证依赖文件版本
4. 测试不同环境
5. 提供兼容性方案
```

---

*下一步：查看 [性能优化](../06-进阶技巧/性能优化.md)*