# 格式检查工具

## 🔍 自动检查工具

### PVF格式验证器

#### 功能特点
- **语法检查**：验证标签格式和嵌套结构
- **字符串检查**：确保使用反引号而非双引号
- **缩进检查**：验证Tab缩进的正确使用
- **依赖检查**：验证引用文件是否存在
- **编码检查**：确保文件编码正确

#### 使用方法

**命令行版本**：
```bash
# 检查单个文件
python pvf_checker.py example.obj

# 批量检查目录
python pvf_checker.py --dir ./passiveobject/

# 生成检查报告
python pvf_checker.py --report --output check_report.html
```

**图形界面版本**：
```
┌─────────────────────────────────────┐
│ PVF格式检查器 v1.0                  │
├─────────────────────────────────────┤
│ 文件路径: [选择文件...] [浏览]      │
│ 检查选项: ☑语法 ☑字符串 ☑缩进      │
│ 输出格式: ○控制台 ●HTML报告        │
│                                     │
│ [开始检查] [清除结果] [保存报告]    │
├─────────────────────────────────────┤
│ 检查结果:                           │
│ ✓ 语法结构正确                      │
│ ✗ 第15行: 发现双引号                │
│ ✗ 第23行: 缩进使用空格              │
│ ⚠ 第30行: 引用文件不存在            │
└─────────────────────────────────────┘
```

### 详细检查脚本

#### Python完整版本
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PVF文件格式检查器
支持OBJ、EQU、SKL等PVF格式文件的语法检查
"""

import os
import re
import sys
import json
import argparse
from pathlib import Path
from typing import List, Dict, Tuple

class PVFChecker:
    """PVF文件格式检查器"""
    
    def __init__(self):
        self.errors = []
        self.warnings = []
        self.info = []
        
        # 定义检查规则
        self.rules = {
            'required_tags': ['[name]'],
            'string_pattern': r'`[^`]*`',
            'invalid_string_pattern': r'"[^"]*"',
            'tag_pattern': r'\[[^\]]+\]',
            'comment_pattern': r'#.*$',
            'tab_pattern': r'^\t+',
            'space_indent_pattern': r'^[ ]{2,}'
        }
    
    def check_file(self, filepath: str) -> Dict:
        """检查单个文件"""
        self.errors.clear()
        self.warnings.clear()
        self.info.clear()
        
        if not os.path.exists(filepath):
            self.errors.append(f"文件不存在: {filepath}")
            return self._get_result()
        
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except UnicodeDecodeError:
            try:
                with open(filepath, 'r', encoding='gbk') as f:
                    lines = f.readlines()
                self.warnings.append("文件编码为GBK，建议使用UTF-8")
            except Exception as e:
                self.errors.append(f"无法读取文件: {e}")
                return self._get_result()
        except Exception as e:
            self.errors.append(f"读取文件时出错: {e}")
            return self._get_result()
        
        # 执行各项检查
        self._check_file_header(lines)
        self._check_string_format(lines)
        self._check_indentation(lines)
        self._check_required_tags(lines)
        self._check_tag_structure(lines)
        self._check_file_references(lines, filepath)
        
        return self._get_result()
    
    def _check_file_header(self, lines: List[str]):
        """检查文件头"""
        if not lines:
            self.errors.append("文件为空")
            return
        
        first_line = lines[0].strip()
        if not first_line.startswith('#PVF_File'):
            self.errors.append("缺少文件头 #PVF_File")
    
    def _check_string_format(self, lines: List[str]):
        """检查字符串格式"""
        for i, line in enumerate(lines, 1):
            # 跳过注释行
            if line.strip().startswith('#'):
                continue
            
            # 检查双引号
            if re.search(self.rules['invalid_string_pattern'], line):
                self.errors.append(f"第{i}行: 发现双引号，应使用反引号")
            
            # 检查未闭合的反引号
            backtick_count = line.count('`')
            if backtick_count % 2 != 0:
                self.warnings.append(f"第{i}行: 反引号未成对出现")
    
    def _check_indentation(self, lines: List[str]):
        """检查缩进格式"""
        for i, line in enumerate(lines, 1):
            # 检查空格缩进
            if re.match(self.rules['space_indent_pattern'], line):
                self.errors.append(f"第{i}行: 使用空格缩进，应使用Tab")
            
            # 检查混合缩进
            if line.startswith('\t') and '    ' in line[:10]:
                self.warnings.append(f"第{i}行: 混合使用Tab和空格")
    
    def _check_required_tags(self, lines: List[str]):
        """检查必需标签"""
        content = ''.join(lines)
        
        for tag in self.rules['required_tags']:
            if tag not in content:
                self.errors.append(f"缺少必需标签: {tag}")
    
    def _check_tag_structure(self, lines: List[str]):
        """检查标签结构"""
        tag_stack = []
        
        for i, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # 查找标签
            tags = re.findall(self.rules['tag_pattern'], line)
            for tag in tags:
                if tag.startswith('[/'):
                    # 结束标签
                    expected_start = tag[2:-1]
                    if not tag_stack:
                        self.errors.append(f"第{i}行: 未匹配的结束标签 {tag}")
                    elif tag_stack[-1] != expected_start:
                        self.errors.append(f"第{i}行: 标签不匹配，期望 [/{tag_stack[-1]}]，实际 {tag}")
                    else:
                        tag_stack.pop()
                elif not any(tag.endswith(end) for end in [']', '`']):
                    # 开始标签（排除单行标签）
                    tag_name = tag[1:-1]
                    tag_stack.append(tag_name)
        
        # 检查未闭合的标签
        if tag_stack:
            self.warnings.append(f"未闭合的标签: {tag_stack}")
    
    def _check_file_references(self, lines: List[str], current_file: str):
        """检查文件引用"""
        base_dir = os.path.dirname(current_file)
        
        for i, line in enumerate(lines, 1):
            # 查找文件引用
            matches = re.findall(r'`([^`]*\.(act|atk|ani|wav|ogg))`', line, re.IGNORECASE)
            
            for match in matches:
                ref_file = match[0]
                
                # 构建完整路径
                if not os.path.isabs(ref_file):
                    full_path = os.path.join(base_dir, ref_file)
                else:
                    full_path = ref_file
                
                if not os.path.exists(full_path):
                    self.warnings.append(f"第{i}行: 引用文件不存在 - {ref_file}")
    
    def _get_result(self) -> Dict:
        """获取检查结果"""
        return {
            'errors': self.errors.copy(),
            'warnings': self.warnings.copy(),
            'info': self.info.copy(),
            'total_issues': len(self.errors) + len(self.warnings)
        }

class PVFBatchChecker:
    """批量检查器"""
    
    def __init__(self):
        self.checker = PVFChecker()
    
    def check_directory(self, directory: str, extensions: List[str] = None) -> Dict:
        """检查目录下的所有文件"""
        if extensions is None:
            extensions = ['.obj', '.equ', '.skl']
        
        results = {}
        total_files = 0
        total_errors = 0
        total_warnings = 0
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                if any(file.lower().endswith(ext) for ext in extensions):
                    filepath = os.path.join(root, file)
                    result = self.checker.check_file(filepath)
                    
                    results[filepath] = result
                    total_files += 1
                    total_errors += len(result['errors'])
                    total_warnings += len(result['warnings'])
        
        return {
            'files': results,
            'summary': {
                'total_files': total_files,
                'total_errors': total_errors,
                'total_warnings': total_warnings,
                'clean_files': sum(1 for r in results.values() if r['total_issues'] == 0)
            }
        }
    
    def generate_html_report(self, results: Dict, output_file: str):
        """生成HTML报告"""
        html_template = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PVF格式检查报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .summary { background: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .file-result { margin-bottom: 20px; border: 1px solid #ddd; border-radius: 5px; }
        .file-header { background: #e9e9e9; padding: 10px; font-weight: bold; }
        .error { color: #d32f2f; margin: 5px 0; }
        .warning { color: #f57c00; margin: 5px 0; }
        .success { color: #388e3c; }
        .issues { padding: 10px; }
    </style>
</head>
<body>
    <h1>PVF格式检查报告</h1>
    
    <div class="summary">
        <h2>检查摘要</h2>
        <p>总文件数: {total_files}</p>
        <p>错误总数: {total_errors}</p>
        <p>警告总数: {total_warnings}</p>
        <p>无问题文件: {clean_files}</p>
    </div>
    
    <div class="results">
        <h2>详细结果</h2>
        {file_results}
    </div>
</body>
</html>
        """
        
        file_results_html = ""
        for filepath, result in results['files'].items():
            status_class = "success" if result['total_issues'] == 0 else "error"
            status_text = "✓ 通过" if result['total_issues'] == 0 else f"✗ {result['total_issues']} 个问题"
            
            issues_html = ""
            for error in result['errors']:
                issues_html += f'<div class="error">✗ 错误: {error}</div>'
            for warning in result['warnings']:
                issues_html += f'<div class="warning">⚠ 警告: {warning}</div>'
            
            file_results_html += f"""
            <div class="file-result">
                <div class="file-header">
                    <span class="{status_class}">{status_text}</span> - {os.path.basename(filepath)}
                    <br><small>{filepath}</small>
                </div>
                <div class="issues">{issues_html or '<div class="success">无问题</div>'}</div>
            </div>
            """
        
        html_content = html_template.format(
            total_files=results['summary']['total_files'],
            total_errors=results['summary']['total_errors'],
            total_warnings=results['summary']['total_warnings'],
            clean_files=results['summary']['clean_files'],
            file_results=file_results_html
        )
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

def main():
    parser = argparse.ArgumentParser(description='PVF文件格式检查器')
    parser.add_argument('path', help='要检查的文件或目录路径')
    parser.add_argument('--dir', action='store_true', help='检查整个目录')
    parser.add_argument('--report', action='store_true', help='生成HTML报告')
    parser.add_argument('--output', default='check_report.html', help='报告输出文件名')
    parser.add_argument('--extensions', nargs='+', default=['.obj', '.equ', '.skl'], 
                       help='要检查的文件扩展名')
    
    args = parser.parse_args()
    
    if args.dir or os.path.isdir(args.path):
        # 批量检查
        batch_checker = PVFBatchChecker()
        results = batch_checker.check_directory(args.path, args.extensions)
        
        print(f"检查完成！")
        print(f"总文件数: {results['summary']['total_files']}")
        print(f"错误总数: {results['summary']['total_errors']}")
        print(f"警告总数: {results['summary']['total_warnings']}")
        print(f"无问题文件: {results['summary']['clean_files']}")
        
        if args.report:
            batch_checker.generate_html_report(results, args.output)
            print(f"HTML报告已生成: {args.output}")
        
        # 显示有问题的文件
        for filepath, result in results['files'].items():
            if result['total_issues'] > 0:
                print(f"\n{filepath}:")
                for error in result['errors']:
                    print(f"  ✗ 错误: {error}")
                for warning in result['warnings']:
                    print(f"  ⚠ 警告: {warning}")
    
    else:
        # 单文件检查
        checker = PVFChecker()
        result = checker.check_file(args.path)
        
        print(f"检查文件: {args.path}")
        
        if result['total_issues'] == 0:
            print("✓ 文件格式正确！")
        else:
            print(f"发现 {result['total_issues']} 个问题:")
            for error in result['errors']:
                print(f"  ✗ 错误: {error}")
            for warning in result['warnings']:
                print(f"  ⚠ 警告: {warning}")

if __name__ == "__main__":
    main()
```

## 🛠️ 快速检查工具

### 一键检查脚本

#### Windows批处理版本
```batch
@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

echo ================================
echo     PVF文件快速检查工具
echo ================================
echo.

set /a total_files=0
set /a error_files=0
set /a total_errors=0

REM 检查当前目录下的所有OBJ文件
for %%f in (*.obj) do (
    set /a total_files+=1
    set current_errors=0
    
    echo 检查文件: %%f
    
    REM 检查文件头
    findstr /b "#PVF_File" "%%f" >nul 2>&1
    if !errorlevel! neq 0 (
        echo   ✗ 错误: 缺少文件头 #PVF_File
        set /a current_errors+=1
    )
    
    REM 检查双引号
    findstr /n "\"" "%%f" | findstr /v "^[0-9]*:#" >nul 2>&1
    if !errorlevel! equ 0 (
        echo   ✗ 错误: 发现双引号，应使用反引号
        set /a current_errors+=1
    )
    
    REM 检查必需标签
    findstr "\[name\]" "%%f" >nul 2>&1
    if !errorlevel! neq 0 (
        echo   ✗ 错误: 缺少必需标签 [name]
        set /a current_errors+=1
    )
    
    REM 检查空格缩进
    findstr /r "^  " "%%f" >nul 2>&1
    if !errorlevel! equ 0 (
        echo   ⚠ 警告: 发现空格缩进，建议使用Tab
        set /a current_errors+=1
    )
    
    if !current_errors! equ 0 (
        echo   ✓ 格式正确
    ) else (
        set /a error_files+=1
        set /a total_errors+=!current_errors!
    )
    echo.
)

echo ================================
echo 检查完成！
echo 总文件数: !total_files!
echo 有问题文件: !error_files!
echo 总问题数: !total_errors!
echo ================================

if !error_files! equ 0 (
    echo ✓ 所有文件格式正确！
) else (
    echo ⚠ 发现问题，请检查上述错误
)

pause
```

### 在线检查工具

#### Web版本界面
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PVF在线格式检查器</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .upload-area { border: 2px dashed #ccc; padding: 40px; text-align: center; margin: 20px 0; }
        .upload-area.dragover { border-color: #007cba; background: #f0f8ff; }
        .result { margin: 20px 0; padding: 15px; border-radius: 5px; }
        .result.success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .result.error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .result.warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        textarea { width: 100%; height: 300px; font-family: monospace; }
        button { background: #007cba; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
        button:hover { background: #005a87; }
    </style>
</head>
<body>
    <h1>PVF在线格式检查器</h1>
    
    <div class="upload-area" id="uploadArea">
        <p>拖拽OBJ文件到此处，或点击选择文件</p>
        <input type="file" id="fileInput" accept=".obj" style="display: none;">
        <button onclick="document.getElementById('fileInput').click()">选择文件</button>
    </div>
    
    <div>
        <h3>或直接粘贴代码：</h3>
        <textarea id="codeInput" placeholder="在此粘贴OBJ文件内容..."></textarea>
        <br><br>
        <button onclick="checkCode()">检查格式</button>
        <button onclick="clearResults()">清除结果</button>
    </div>
    
    <div id="results"></div>
    
    <script>
        // 文件拖拽处理
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('codeInput').value = e.target.result;
                checkCode();
            };
            reader.readAsText(file, 'utf-8');
        }
        
        function checkCode() {
            const code = document.getElementById('codeInput').value;
            if (!code.trim()) {
                showResult('请输入或选择OBJ文件内容', 'warning');
                return;
            }
            
            const results = performCheck(code);
            displayResults(results);
        }
        
        function performCheck(code) {
            const lines = code.split('\n');
            const errors = [];
            const warnings = [];
            
            // 检查文件头
            if (!lines[0] || !lines[0].trim().startsWith('#PVF_File')) {
                errors.push('缺少文件头 #PVF_File');
            }
            
            // 检查每一行
            lines.forEach((line, index) => {
                const lineNum = index + 1;
                
                // 跳过注释行
                if (line.trim().startsWith('#')) return;
                
                // 检查双引号
                if (line.includes('"') && !line.trim().startsWith('#')) {
                    errors.push(`第${lineNum}行: 发现双引号，应使用反引号`);
                }
                
                // 检查空格缩进
                if (/^  /.test(line)) {
                    warnings.push(`第${lineNum}行: 使用空格缩进，建议使用Tab`);
                }
                
                // 检查未闭合的反引号
                const backtickCount = (line.match(/`/g) || []).length;
                if (backtickCount % 2 !== 0) {
                    warnings.push(`第${lineNum}行: 反引号未成对出现`);
                }
            });
            
            // 检查必需标签
            if (!code.includes('[name]')) {
                errors.push('缺少必需标签 [name]');
            }
            
            return { errors, warnings };
        }
        
        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            if (results.errors.length === 0 && results.warnings.length === 0) {
                showResult('✓ 文件格式正确！', 'success');
                return;
            }
            
            if (results.errors.length > 0) {
                const errorHtml = '<h4>错误：</h4><ul>' + 
                    results.errors.map(error => `<li>✗ ${error}</li>`).join('') + 
                    '</ul>';
                showResult(errorHtml, 'error');
            }
            
            if (results.warnings.length > 0) {
                const warningHtml = '<h4>警告：</h4><ul>' + 
                    results.warnings.map(warning => `<li>⚠ ${warning}</li>`).join('') + 
                    '</ul>';
                showResult(warningHtml, 'warning');
            }
        }
        
        function showResult(message, type) {
            const resultsDiv = document.getElementById('results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `result ${type}`;
            resultDiv.innerHTML = message;
            resultsDiv.appendChild(resultDiv);
        }
        
        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('codeInput').value = '';
        }
    </script>
</body>
</html>
```

## 📊 检查报告示例

### 控制台输出格式
```
PVF格式检查报告
================

文件: example.obj
✓ 文件头正确
✗ 第15行: 发现双引号，应使用反引号
⚠ 第23行: 使用空格缩进，建议使用Tab
✗ 第30行: 缺少必需标签 [name]

总计: 2个错误, 1个警告

建议修复:
1. 将第15行的双引号改为反引号
2. 将第23行的空格缩进改为Tab缩进
3. 添加 [name] 标签
```

### HTML报告格式
- **概览统计**：文件总数、错误数、警告数
- **文件列表**：每个文件的检查状态
- **详细问题**：具体的错误和警告信息
- **修复建议**：针对性的解决方案

---

*下一步：查看 [调试技巧](../04-常见问题/调试技巧.md)*