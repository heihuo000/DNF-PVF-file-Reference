# OBJ文件性能优化指南

## 📋 概述

OBJ文件的性能优化对于游戏流畅度至关重要。本文档提供了全面的性能优化策略和技巧。

## 🎯 优化原则

### 1. 减少对象数量
```obj
# ❌ 错误：创建过多小对象
[name] `effect_spark_01`
[width] 10
[layer] `[normal]`
[basic action] `Action/spark_small.act`

[name] `effect_spark_02`
[width] 10
[layer] `[normal]`
[basic action] `Action/spark_small.act`

# ✅ 正确：合并为单个对象
[name] `effect_spark_combined`
[width] 50
[layer] `[normal]`
[basic action] `Action/spark_combined.act`
```

### 2. 优化生命周期
```obj
# ❌ 错误：无限生存时间
[name] `persistent_effect`
[width] 100
[layer] `[normal]`
[basic action] `Action/persistent.act`
# 没有销毁条件

# ✅ 正确：设置合理的销毁条件
[name] `timed_effect`
[width] 100
[layer] `[normal]`
[basic action] `Action/timed.act`
[object destroy condition]
	`time`	3000	# 3秒后自动销毁
[/object destroy condition]
```

## 🔧 具体优化技巧

### 1. 层级优化

#### 合理使用层级
```obj
# 背景效果使用底层
[name] `background_glow`
[layer] `[bottom]`
[layer level] 1

# 主要效果使用普通层
[name] `main_effect`
[layer] `[normal]`
[layer level] 50

# 重要提示使用覆盖层
[name] `critical_warning`
[layer] `[cover]`
[layer level] 100
```

#### 避免层级冲突
```obj
# ❌ 错误：相同层级导致渲染冲突
[name] `effect_a`
[layer] `[normal]`
[layer level] 50

[name] `effect_b`
[layer] `[normal]`
[layer level] 50

# ✅ 正确：错开层级
[name] `effect_a`
[layer] `[normal]`
[layer level] 49

[name] `effect_b`
[layer] `[normal]`
[layer level] 51
```

### 2. 尺寸优化

#### 最小化碰撞检测范围
```obj
# ❌ 错误：过大的碰撞范围
[name] `small_projectile`
[width] 200	# 实际只需要20
[height] 200

# ✅ 正确：精确的碰撞范围
[name] `small_projectile`
[width] 20
[height] 20
```

#### 动态调整尺寸
```obj
# 根据效果阶段调整尺寸
[name] `expanding_blast`
[width] 50	# 初始尺寸
[height] 50
[basic action] `Action/expanding_blast.act`	# ACT文件中处理尺寸变化
```

### 3. 动作优化

#### 减少动画帧数
```obj
# ❌ 错误：过多动画帧
[basic action] `Action/detailed_effect.act`	# 60帧动画

# ✅ 正确：优化后的动画
[basic action] `Action/optimized_effect.act`	# 30帧动画，视觉效果相近
```

#### 使用循环动画
```obj
# 循环播放减少内存占用
[name] `looping_aura`
[basic action] `Action/aura_loop.act`	# 短循环动画
[object destroy condition]
	`time`	5000	# 5秒后销毁
[/object destroy condition]
```

## 📊 性能监控

### 1. 对象计数监控
```python
# Python脚本：监控OBJ对象数量
import re
import os

def count_obj_files(directory):
    """统计目录中的OBJ文件数量"""
    obj_count = 0
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.obj'):
                obj_count += 1
    return obj_count

def analyze_obj_complexity(file_path):
    """分析单个OBJ文件的复杂度"""
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 统计标签数量
    tag_count = len(re.findall(r'\[.*?\]', content))
    
    # 检查是否有销毁条件
    has_destroy_condition = 'object destroy condition' in content
    
    # 检查动作文件引用
    action_refs = re.findall(r'Action/.*?\.act', content)
    
    return {
        'tag_count': tag_count,
        'has_destroy_condition': has_destroy_condition,
        'action_references': len(action_refs)
    }

# 使用示例
directory = "passiveobject/"
total_objs = count_obj_files(directory)
print(f"总OBJ文件数量: {total_objs}")
```

### 2. 内存使用分析
```python
# 内存使用估算脚本
def estimate_memory_usage(obj_file):
    """估算OBJ文件的内存使用"""
    with open(obj_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 基础内存占用
    base_memory = 1024  # 1KB基础
    
    # 根据宽高计算
    width_match = re.search(r'\[width\]\s*(\d+)', content)
    height_match = re.search(r'\[height\]\s*(\d+)', content)
    
    if width_match and height_match:
        width = int(width_match.group(1))
        height = int(height_match.group(1))
        collision_memory = (width * height) // 100  # 简化计算
    else:
        collision_memory = 0
    
    # 动作文件内存
    action_count = len(re.findall(r'Action/.*?\.act', content))
    action_memory = action_count * 2048  # 每个动作约2KB
    
    total_memory = base_memory + collision_memory + action_memory
    return total_memory

# 批量分析
def analyze_directory_memory(directory):
    """分析目录内存使用"""
    total_memory = 0
    file_count = 0
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.obj'):
                file_path = os.path.join(root, file)
                memory = estimate_memory_usage(file_path)
                total_memory += memory
                file_count += 1
                print(f"{file}: {memory} bytes")
    
    print(f"\n总计: {file_count} 个文件, {total_memory} bytes ({total_memory/1024:.2f} KB)")
```

## ⚡ 高级优化技巧

### 1. 对象池化
```obj
# 创建可重用的通用效果对象
[name] `generic_explosion`
[width] 100
[height] 100
[layer] `[normal]`
[basic action] `Action/generic_explosion.act`
[object destroy condition]
	`time`	2000
[/object destroy condition]

# 通过参数控制不同效果
[category] `reusable_effect`	# 标记为可重用
```

### 2. 延迟加载
```obj
# 标记为延迟加载的对象
[name] `heavy_effect`
[width] 200
[height] 200
[layer] `[normal]`
[basic action] `Action/heavy_effect.act`
[category] `lazy_load`	# 需要时才加载
```

### 3. LOD（细节层次）系统
```obj
# 高质量版本（近距离）
[name] `effect_high_lod`
[width] 100
[height] 100
[basic action] `Action/effect_detailed.act`

# 低质量版本（远距离）
[name] `effect_low_lod`
[width] 100
[height] 100
[basic action] `Action/effect_simple.act`
```

## 🔍 性能测试

### 1. 压力测试脚本
```python
# 性能压力测试
import time
import psutil
import subprocess

def performance_test(obj_directory):
    """执行性能测试"""
    print("开始性能测试...")
    
    # 记录初始状态
    initial_memory = psutil.virtual_memory().used
    start_time = time.time()
    
    # 模拟加载所有OBJ文件
    obj_files = []
    for root, dirs, files in os.walk(obj_directory):
        for file in files:
            if file.endswith('.obj'):
                obj_files.append(os.path.join(root, file))
    
    print(f"找到 {len(obj_files)} 个OBJ文件")
    
    # 模拟处理
    for obj_file in obj_files:
        with open(obj_file, 'r', encoding='utf-8') as f:
            content = f.read()
        # 模拟解析处理
        time.sleep(0.001)  # 模拟处理时间
    
    # 记录结束状态
    end_time = time.time()
    final_memory = psutil.virtual_memory().used
    
    print(f"处理时间: {end_time - start_time:.2f} 秒")
    print(f"内存增长: {(final_memory - initial_memory) / 1024 / 1024:.2f} MB")

# 运行测试
performance_test("passiveobject/")
```

### 2. 自动化优化建议
```python
def generate_optimization_report(obj_file):
    """生成优化建议报告"""
    with open(obj_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    suggestions = []
    
    # 检查销毁条件
    if 'object destroy condition' not in content:
        suggestions.append("建议添加销毁条件以避免内存泄漏")
    
    # 检查尺寸
    width_match = re.search(r'\[width\]\s*(\d+)', content)
    if width_match and int(width_match.group(1)) > 500:
        suggestions.append("对象宽度过大，考虑减小以提高性能")
    
    # 检查层级
    if '[layer level]' not in content:
        suggestions.append("建议明确指定层级以避免渲染冲突")
    
    return suggestions

# 批量生成报告
def batch_optimization_report(directory):
    """批量生成优化报告"""
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.obj'):
                file_path = os.path.join(root, file)
                suggestions = generate_optimization_report(file_path)
                if suggestions:
                    print(f"\n{file}:")
                    for suggestion in suggestions:
                        print(f"  - {suggestion}")
```

## 📈 性能基准

### 推荐指标
- **单个OBJ文件大小**: < 2KB
- **对象生存时间**: < 10秒
- **同时存在对象数**: < 50个
- **碰撞检测范围**: 尽可能小
- **动画帧数**: < 30帧

### 性能等级
| 等级 | 对象数量 | 内存使用 | 处理时间 |
|------|----------|----------|----------|
| 优秀 | < 20 | < 10MB | < 0.1s |
| 良好 | 20-50 | 10-25MB | 0.1-0.3s |
| 一般 | 50-100 | 25-50MB | 0.3-0.5s |
| 需优化 | > 100 | > 50MB | > 0.5s |

## 🚨 常见性能问题

### 1. 内存泄漏
```obj
# 问题：没有销毁条件
[name] `permanent_effect`
[basic action] `Action/loop.act`

# 解决：添加销毁条件
[name] `timed_effect`
[basic action] `Action/loop.act`
[object destroy condition]
	`time`	5000
[/object destroy condition]
```

### 2. 过度渲染
```obj
# 问题：层级混乱
[layer] `[cover]`	# 不必要的覆盖层

# 解决：使用合适层级
[layer] `[normal]`
[layer level] 10
```

### 3. 碰撞检测开销
```obj
# 问题：过大的碰撞范围
[width] 1000
[height] 1000

# 解决：精确的碰撞范围
[width] 50
[height] 50
```

## 💡 最佳实践

1. **定期性能审查**: 每月检查一次OBJ文件性能
2. **使用性能工具**: 利用自动化脚本监控性能
3. **渐进式优化**: 优先优化影响最大的文件
4. **测试验证**: 每次优化后进行性能测试
5. **文档记录**: 记录优化过程和效果

## 🔗 相关资源

- [OBJ文件概述](../01-基础信息/OBJ文件概述.md)
- [调试技巧](../04-常见问题/调试技巧.md)
- [格式检查工具](../05-实用工具/格式检查工具.md)
- [PVF文件格式规范](../../PVF文件格式规范.md)